> Orca is a modern top-down query optimizer based on the Cascades optimization framework.
>
> ORCA是一个基于Cascades查询优化框架的自顶向下的查询优化器。

# 架构

## Memo
> The Memo structure consists of a set of containers called groups, where each group contains logically equivalent expressions. Memo groups capture the different sub-goals of a query (e.g., a filter on a table, or a join of two tables). Group members, called group expressions, achieve the group goal in different logical ways
> 
> 

## Search and Job Scheduler
> Orca uses a search mechanism to navigate through the space of possible plan alternatives and <b><font color=FA8072>identify the plan with the least estimated cost</font></b>. The search mechanism is enabled by a specialized Job Scheduler that creates dependent or parallel work units to perform query optimization in three main steps: <b><font color=FA8072>exploration</font></b>, where equivalent logical expressions are generated, <b><font color=FA8072>implementation</font></b> where physical plans are generated, and <b><font color=FA8072>optimization</font></b>, where required physical properties (e.g., sort order) are enforced and plan alternatives are costed.

## Transformations
> Plan alternatives are generated by applying transformation rules that can produce either equivalent logical expressions (e.g., InnerJoin(A,B) → InnerJoin(B,A)), or physical implementations of existing expressions (e.g., Join(A,B) → HashJoin(A,B)).

## Property Enforcement
> Properties have different types including<b><font color=FA8072> logical properties</font></b> (e.g.,output columns), <b><font color=FA8072>physical properties</font></b> (e.g., sort order and data distribution), and <b><font color=FA8072>scalar properties</font></b>  (e.g., columns used in join conditions). During query optimization, each operator may request specific properties from its children. An optimized child plan may either satisfy the required properties on its own,or an *enforcer* (e.g., a Sort operator) needs to be plugged inthe plan to deliver the required property. The framework allows each operator to control enforcers placement based on child plans’ properties and operator’s local behavior

# Optimization Workflow

1. **Exploration.** Transformation rules that generate logically equivalent expressions are triggered.
2.  **Statistics Derivation.** At the end of exploration, the Memo maintains the complete logical space of the given query. Orca’s statistics derivation mechanism is then triggered to compute statistics for the Memo groups. <b><font color=FA8072>A statistics object in Orca is mainly a collection of column histograms used to derive estimates for cardinality and data skew. </font></b>Derivation of statistics takes place on the compact Memo structure to avoid expanding the search space.

> <b><font color=FA8072>In order to derive statistics for a target group, Orca picks the group expression with the highest promise of delivering reliable statistics. Statistics promise computation is expression-specific.</font></b> For example, an InnerJoin expression with a small number of join conditions is more promising than another equivalent InnerJoin expression with a larger number of join conditions 

3. **Implementation.** Transformation rules that create physical implementations of logical expressions are triggered.
4. **Optimization.** In this step, properties are enforced and plan alternatives are costed. Optimization starts by submitting an initial *optimization request* to the Memo’s root group specifying query requirements such as result distribution and sort order. 

> Property enforcement in Orca in a flflexible framework that allows each operator to defifine the behav ior of enforcing required properties based on the properties delivered by child plans and operator local behavior.

**Multi-Stage Optimization**

> Our ongoing work in Orca involves implementing multi-stage optimization. An optimization stage in Orca is defined as a complete optimization workflow using a subset of transformation rules and (optional) time-out and cost threshold. A stage terminates when any of the following conditions is met: 
>
> 1. a planwith cost below cost threshold is found,
> 2. time-out occurs, or 
> 3.  the subset of transformation rules is exhausted.
>
> 
>
> This technique is also a foundation for obtaining a query plan as early as possible to cut-down search space for complex queries.

# **Parallel Query Optimization**

Query optimization is probably the most <b><font color=FA8072>CPU-intensive process</font></b> in a database system.



Orca is a multi-core enabled optimizer. Optimization process is broken to small work units called optimization jobs. Orca currently has seven different types of optimization jobs:

- Exp(g): Generate logically equivalent expressions of all group expressions in group g.
- Exp(gexpr): Generate logically equivalent expressions of a group expression gexpr.
- Imp(g): Generate implementations of all group expressions in group g.
- Imp(gexpr): Generate implementation alternatives of a group expression gexpr.
- Opt(g, req): Return the plan with the least estimated cost that is rooted by an operator in group g and satisfies optimization request req.
- Opt(gexpr, req): Return the plan with the least estimated cost that is rooted by gexpr and satisfies optimization request req.
- Xform(gexpr, t) Transform group expression gexpr using rule t.

> During parallel query optimization, multiple concurrent requests to modify a Memo group might be triggered by different optimization requests. In order to <b><font color=FA8072>minimize synchronization overhead</font></b> among jobs with the same goal (e.g.,exploring the same group), jobs should not know about the existence of each other. When an optimization job with some goal is under processing, all other incoming jobs with the same goal are forced to wait until getting notified about the completion of the running job. At this point, the suspended jobs can pick up the results of the completed job. This functionality is enabled by attaching a job queue to each group, such that incoming jobs are queued as long as there exists an active job with the same goal.

# 博客

1. [数据库内核杂谈（九）：开源优化器ORCA](https://www.infoq.cn/article/5o16ehoz5zk6fzpsjpt2)
