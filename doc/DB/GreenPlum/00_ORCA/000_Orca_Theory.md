> Orca is a modern top-down query optimizer based on the Cascades optimization framework.
>
> ORCA是一个基于Cascades查询优化框架的自顶向下的查询优化器。

# 架构

## Memo
> The Memo structure consists of a set of containers called groups, where each group contains logically equivalent expressions. Memo groups capture the different sub-goals of a query (e.g., a filter on a table, or a join of two tables). Group members, called group expressions, achieve the group goal in different logical ways
> 
> 

## Search and Job Scheduler
> Orca uses a search mechanism to navigate through the space of possible plan alternatives and <b><font color=FA8072>identify the plan with the least estimated cost</font></b>. The search mechanism is enabled by a specialized Job Scheduler that creates dependent or parallel work units to perform query optimization in three main steps: <b><font color=FA8072>exploration</font></b>, where equivalent logical expressions are generated, <b><font color=FA8072>implementation</font></b> where physical plans are generated, and <b><font color=FA8072>optimization</font></b>, where required physical properties (e.g., sort order) are enforced and plan alternatives are costed.

## Transformations
> Plan alternatives are generated by applying transformation rules that can produce either equivalent logical expressions (e.g., InnerJoin(A,B) → InnerJoin(B,A)), or physical implementations of existing expressions (e.g., Join(A,B) → HashJoin(A,B)).

## Property Enforcement
> Properties have different types including<b><font color=FA8072> logical properties</font></b> (e.g.,output columns), <b><font color=FA8072>physical properties</font></b> (e.g., sort order and data distribution), and <b><font color=FA8072>scalar properties</font></b>  (e.g., columns used in join conditions). During query optimization, each operator may request specific properties from its children. An optimized child plan may either satisfy the required properties on its own,or an *enforcer* (e.g., a Sort operator) needs to be plugged inthe plan to deliver the required property. The framework allows each operator to control enforcers placement based on child plans’ properties and operator’s local behavior

# Optimization Workflow

1. **Exploration.** Transformation rules that generate logically equivalent expressions are triggered.
2.  **Statistics Derivation.** At the end of exploration, the Memo maintains the complete logical space of the given query. Orca’s statistics derivation mechanism is then triggered to compute statistics for the Memo groups. <b><font color=FA8072>A statistics object in Orca is mainly a collection of column histograms used to derive estimates for cardinality and data skew. </font></b>Derivation of statistics takes place on the compact Memo structure to avoid expanding the search space.

> <b><font color=FA8072>In order to derive statistics for a target group, Orca picks the group expression with the highest promise of delivering reliable statistics. Statistics promise computation is expression-specific.</font></b> For example, an InnerJoin expression with a small number of join conditions is more promising than another equivalent InnerJoin expression with a larger number of join conditions 

3. **Implementation.** Transformation rules that create physical implementations of logical expressions are triggered.
4. **Optimization.** In this step, properties are enforced and plan alternatives are costed. Optimization starts by submitting an initial *optimization request* to the Memo’s root group specifying query requirements such as result distribution and sort order. 

> Property enforcement in Orca in a flflexible framework that allows each operator to defifine the behav ior of enforcing required properties based on the properties delivered by child plans and operator local behavior.

# 博客

1. [数据库内核杂谈（九）：开源优化器ORCA](https://www.infoq.cn/article/5o16ehoz5zk6fzpsjpt2)
