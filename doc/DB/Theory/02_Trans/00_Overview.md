事务是指数据库中一个不可分的逻辑工作单元，它允许将多个操作表示为一个步骤。数据库事务必须遵从原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)和持久性(Durability)，这些属性通常合称为ACID：
1. 原子性，事务的步骤是不可分的，这意味着，事务中的所有步骤要么全都执行成功，要么全都不执行。换句话说，事务不应当被部分应用。每个事务要么成功提交(使事务内写操作产生的所有更改变得可见)，要么中止(回滚所有尚不可见的事务副作用)。提交是事务的最后一个操作。中止后可以重试该事务。
2. 一致性，一种特定于具体应用的保证：事务只能将数据库从一个有效状态带到另一个有效状态，并保持所有的数据库不变量(比如约束、引用完整性等)。一致性是定义最弱的属性，可能因为它是唯一一个由用户控制而不是仅凭数据库自身保证的属性。
3. 隔离性，多个并发执行的事务应该能够互不干扰地运行，每个事务都像没有其他事务在同时执行一样。隔离性定义了何时以及哪些对数据库状态的更改可以对并发事务可见。出于性能原因，许多数据库使用的隔离级别要弱于这里给出的隔离性定义。根据并发控制的实现，一个事务所做的更改可能对其他并发事务可见或不可见。
4. 持久性，一旦事务被提交，所有数据库状态的修改都必须被持久化到磁盘上，即使之后发生断电、系统故障或崩溃也不受影响。



事务处理器分成两个主要部分：并发控制管理器或调度器，负责保证事务的原子性和孤立性；日志和恢复管理器，负责事务的持久性。数据库系统中实现事务需要多个组件协同工作。

1. 事务管理器负责协调、调度和跟踪事务及事务的各个步骤。
2. 锁管理器可保护对资源的访问，并防止那些可能破坏数据完整性的并发访问。每当请求加锁时，锁管理器会检查这个锁是否已被其他事务以共享或排他模式持有，如果请求的访问级别没有冲突则允许本次访问。由于排他锁在任意时刻最多只能被一个事务持有，所以其他请求加锁的事务必须等待锁被释放，或者中止事务并稍后重试。一旦锁被释放或事务终止，锁管理器就会通知其中一个挂起的事务，让它获得锁并继续执行。
3. 页缓存充当了持久性存储(磁盘)和存储引擎其余部分之间的中介。它将状态更改暂存在内存中，同时也用于缓存那些尚未与持久性存储同步的页。一切数据库状态的更改都首先被应用在缓存的页上。
4. 日志管理器记录了已应用在缓存页上的操作(日志条目)，这些操作尚未与持久性存储同步，而日志可以确保这些操作不会在崩溃时丢失。换句话说，在数据库启动期间，利用日志来重新应用这些操作并重建缓存状态。日志条目也可以用来撤销已中止的事务所做的更改。
5. 分布式(多分区)事务需要额外的协调机制以及远程执行。

# 页缓存

大多数数据库都采用双层存储体系：较慢的持久性存储(磁盘)和较快的主内存(RAM)。为了减少对持久性存储的访问次数，页面被缓存在内存中。当存储层再次请求该页时，将返回其缓存副本。假设没有其他进程修改磁盘上的数据，则内存中的缓存页可以被重用，这种做法有时也称为<b><font color=FA8072>虚拟磁盘</font></b>。仅当内存中没有页副本可用时，对虚拟磁盘的读取才会访问物理存储，很多时候，称上述机制为<b><font color=FA8072>页缓存或缓冲池</font></b>。页缓存负责缓存从磁盘读取的页，如果数据库崩溃或意外关闭，则缓存的内容将丢失。其中，<b><font color=FA8072>将未缓存的页从磁盘加载进来的过程称为换入(page in)。</font></b>缓存的页一旦被更改过就成了脏页，直到这些更改被刷写(flush)到磁盘上。由于页缓存的内存区通常比整个数据集小得多，所以页缓存终究会被填满。<b><font color=FA8072>为了换入新页，必须将其中某个页换出(evict)缓存。</font></b>

操作系统同样具有页缓存的概念，操作系统将空闲的内存段用来透明地缓存磁盘内容，以提高I/O系统调用的性能。

> 绕过内核的页缓存
> 很多数据库系统使用O_DIRECT标志打开文件。该标志允许I/O系统调用绕过内核的页缓存直接访问磁盘，并使用数据库专用的缓冲区管理。
>
> Linus Torvalds批评过O_DIRECT的使用，因为它不是异步的，而且没有预读之类的方法来告知内核有关访问模式的信息。但是，在操作系统提供更好的机制之前，O_DIRECT仍然很有用。
>
> 可以通过fadvise这个系统调用从某种程度上控制内核如何将页换出页缓存，但这仅仅是让内核考虑我们的意见，并不保证它一定会发生。为了避免在执行I/O时发生系统调用，可以使用内存映射，但那样我们也失去了对缓存的控制。

页缓存的主要功能：

- 在内存中保留被缓存的页的内容。
- 把对磁盘页的修改缓冲起来，并且修改的是缓存的版本。
-  当被请求的页不在内存中且可用空间足够时，页缓存会将其换入并返回缓存的版本。
-  如果请求的页在缓存中，则直接返回缓存的版本。
-  如果可用空间不足以放下新的页，则某些其他页会被换出，被换出的页的内容会被刷写回磁盘。



## 缓存语义

所有对缓冲区的更改都保留在内存中，直到最终被写回到磁盘上。由于不允许任何其他进程修改磁盘上的这些文件，所以这个<b><font color=FA8072>同步过程是单向的：只能从内存同步到磁盘</font></b>，而不能反过来进行。页缓存让数据库能够更好地控制内存管理和磁盘访问，可以将它视作内核页缓存在应用程序中的等效实现：它直接访问块存储设备，实现类似的功能，也达到了类似的目的。它是<b><font color=FA8072>对磁盘访问的抽象，并将逻辑写操作与物理写操作分离。页缓存使得可以将树部分保留在内存中，而无须修改算法本身或是在内存中物化对象，我们要做的仅是把磁盘访问替换成对页缓存的调用。</font></b>

当存储引擎访问(或请求)页时，我们首先检查其内容是否已被缓存。如果该页在缓存中，则直接返回缓存的页。如果该页未被缓存，则页缓存会将其逻辑地址或页号转换为物理地址，并将它的内容加载到内存，然后返回已缓存的版本给存储引擎。一旦返回，这个存有缓存页内容的缓冲区就称为<b><font color=FA8072>被引用的(referenced)</font></b>，存储引擎必须在用完之后将其归还给页缓存或<b><font color=FA8072>解除引用</font></b>。若想让页缓存不要换出某些页，则可以将它们<b><font color=FA8072>固定(pin)</font></b>。如果某个页被修改了(例如追加了一个新的单元格)，则该页被标记为<b><font color=FA8072>脏页，页上的脏标志位表示其内容与磁盘不同步，必须将其刷写到磁盘上才能保证持久.</font></b>



## 缓存回收

保持缓存填满的状态是件好事：这可以让更多的读请求无须经过持久性存储，也让同一页上更多的修改能被缓冲在一起。但页缓存的容量毕竟是有限的，迟早会用尽所有空间，彼时为了放下新内容只能换出旧页。如果页的内容与磁盘是同步的(已刷写过或从未修改过)，并且该页面未被固定或引用，则可以立即将其换出。脏页则必须在刷写之后才能换出。如果页正在被其他线程使用，则不能将其换出。

如果每次换出页都刷写磁盘，则其性能可能会很差。因此某些数据库使用单独的后台进程，该进程循环检查可能被换出的脏页，更新其磁盘上的版本。例如，PostgreSQL中的一个后台刷写器就是用来做这件事情的。另一个重要属性是持久性：如果数据库崩溃，则所有未刷写的数据都会丢失。为了确保所有更改都被持久化，检查点进程会协调刷写进程。检查点进程控制预写日志(WAL)和页缓存，并确保两者协同工作。只有当缓存页完成刷写之后，相关操作的日志记录才能从WAL中丢弃。在上述过程完成后才能将脏页换出缓存。

这意味着需要在多个目标间做一些权衡：

- 推迟刷写以减少磁盘访问次数。
- 提早刷写以让页能被快速地换出。
-  选择要换出的页，并以最优的顺序刷写。
-  将缓存大小保持在其内存范围内。
-  避免因数据没有被持久化到主存储中而丢失它们。



## 缓存锁定页

每次读取或写入都进行磁盘I/O是不切实际的：并发的读取可能会请求同一页，并发的写入也可能会修改同一页。由于B树越靠近顶部越窄，所以层次较高的节点(靠近根的节点)在大多数读取中都会被命中。分裂与合并操作最终也会传播到较高层次的节点，这意味着至少树的某一部分一定会受益于缓存。<b><font color=FA8072>锁定那些在近期大概率会被用到的页。在缓存中锁定页的操作称为固定，被固定的页会在内存中保留更长的时间，这有助于减少磁盘访问次数并提高性能。</font></b>在B树上，随着节点层次的降低，每层的节点数量呈指数级增加，并且较高层次的节点仅占整棵树的一小部分，因此这部分节点可以永久驻留在内存中，而其他部分则可以按需换入。这意味着，在执行一次查询时我们不必进行h(树的高度)次磁盘访问，只有在访问那些未被缓存的低层页时才会真正读取磁盘。

针对子树执行的操作可能会导致相互矛盾的结构变化，例如：多次删除操作导致节点合并，随后写入又导致分裂，或者相反。从不同子树传播上来的结构变化亦是如此(结构变化的发生时间很接近，但是发生在树的不同部分，并向上传播)。通过仅在内存中应用更改，可以将这些操作缓冲在一起，从而减少磁盘写入的次数并分摊写入成本，因为只要做一次磁盘写入即可，无须写入多次。

> 预取和立即换出缓存
>
> <b><font color=FA8072>页缓存也允许存储引擎对预取和换出进行细粒度的控制，存储引擎可以指示页缓存在访问页之前提前加载页。</font></b>例如，当在范围扫描中遍历叶节点时，可以预加载下一个叶节点。同样，如果后台维护进程加载了某个页，则可以在进程完成后立即将其换出缓存，因为它不太可能被进行中的查询用到。某些数据库(例如PostgreSQL)使用循环缓冲区(即先进先出的页置换策略)进行大规模顺序扫描。



## 页置换

当缓存容量用完时，为了加载新页，必须换出旧页。但是，除非我们换出近期不太可能再次访问的页，否则这些页可能会反复加载多次。为了优化该行为，我们需要找到一种方法来估计后续页被访问的可能性。为此，我们应当根据换出策略(有时也称为页置换策略)将页换出，该策略尝试找出近期最不可能被再次访问的页。当这个页被换出后，新页可以加载到它的位置上。为了实现高效的页缓存，我们需要一种有效的页置换算法，使用正确的页置换策略也能帮助减少换出的次数。

使用更大的缓存能够帮助我们减少换出的次数，这听起来似乎很合理，但事实并非如此。可以说明这种困境的例子之一是<b><font color=FA8072>B閘醖y异常[BEDALY69]</font></b>。它表明，如果使用的页置换算法不是最优的，则增加页数可能导致换出的次数增加。当很快可能会用到的页被换出缓存然后又被再次加载时，页将开始争夺缓存中的空间。

### FIFO和LRU



### CLOCK

CLOCK算法变体常常被用作LRU的一种更加紧凑、更加缓存友好且并发性更好的替代品。例如，Linux使用CLOCK算法的一种变体。CLOCK-sweep算法将页的引用和与之关联的访问位保存在环形缓冲区中。一些变体使用计数器而不是比特位来描述频率。每当访问某个页面时，都将它的访问位设置为1。CLOCK算法的工作原理是循环检查环形缓冲区上的访问位：

- 如果访问位为1且该页未被引用，则将其置为0并检查下一页。
-  如果访问位已经为0，则将该页作为一个要换出的候选，并安排在后续将其换出。
-  如果页当前正被引用，则它的访问位保持不变。算法假定被访问页的访问位不可为0，因此不会被换出缓存，这使得被引用的页更不可能被置换。



### LRU

LRU并非对于所有数据库来说都是最佳的置换策略。有时，考虑将使用频率而非最近使用时间作为预测因子可能更贴合实际。最后，对于负载很重的数据库系统，最近使用时间可能不太具有参考性，因为它只表示项目被访问的顺序。为了改善这一情况，追踪页引用事件而不是页换入事件。其中一种实现是跟踪具有最小使用频率(LFU)的页。

TinyLFU是一种基于频率的页置换策略：TinyLFU不根据页换入的时间来换出页，而是根据使用频率对页进行排序。使用频率直方图来维护一个紧凑的缓存访问历史记录，因为出于实用性考虑，保存完整历史记录的代价太高。元素可能位于以下三个队列中的某一个：

- 入场(admission)队列：维护新加入的元素，用LRU策略实现。
- 考察(probation)队列：其中的元素最有可能被换出缓存。
-  保护(protected)队列：其中的元素将在队列中保留更长的时间。

TinyLFU不是选择要换出哪些元素，而是选择要保留的元素。访问频率相对较高的元素会被晋升到考察队列中。在后续访问中，元素可以从考察队列移至保护队列。如果保护队列已满，则必须将其中某个元素放回考察队列。经常访问的元素有较高的机会被保留，而不经常访问的元素则更有可能被换出缓存。

# 并发控制

事务管理器和锁管理器协同工作以处理并发控制。并发控制是一组用于处理并发事务间交互的技术，在技术实现上可以分为三大类

1. 乐观并发控制(OCC)，<b><font color=FA8072>允许多个事务执行并发的读取和写入操作，最后确定其执行结果能否被串行化</font></b>(serializable)。换句话说，事务不会彼此阻塞，而是保留其操作历史，并在提交前检查这些历史操作是否存在冲突的可能。如果会产生冲突，则中止其中某一个冲突的事务。
2. 多版本并发控制(MVCC)允许一条记录同时存在多个时间戳的版本，通过这种方式<b><font color=FA8072>保证事务读到的是数据库过去某个时刻的一致视图</font></b>。MVCC可以使用验证技术来实现，即只允许多个更新或事务提交中的某一个获胜，也可以使用无锁技术(例如时间戳排序)或基于锁的技术(例如两阶段锁)。
3. 悲观并发控制，也称为保守并发控制(PCC)，既有基于锁的实现，也有不加锁的实现，它们的主要区别在于如何管理和授权对共享资源的访问。基于锁的实现要求事务维护数据库记录上的锁，以防止其他事务修改被加锁的记录或访问当前事务正在修改的记录，直到锁被释放为止。不加锁的实现根据未完成事务的调度，维护读取与写入的操作列表以限制事务的执行。<b><font color=FA8072>悲观的调度可能导致死锁：多个事务需要互相等待对方释放锁才能继续执行</font></b>。

讨论并发控制前，首先明确要解决的问题集，并讨论事务操作会以怎样的方式重叠以及重叠会产生什么样的后果。

# 恢复管理

预写日志(Write-Ahead Log，WAL，也称为提交日志)是一种仅追加的辅助磁盘数据结构，用于崩溃和事务的恢复。页缓存允许我们在内存中缓冲对页面内容的更改，而在将缓存的内容刷写回磁盘之前，WAL是保留操作历史的唯一磁盘副本。许多数据库系统使用仅追加的预写日志，例如PostgreSQL和MySQL。预写日志的主要功能可以概括为：

- 在允许页缓存将页上的修改缓存起来的同时，保证数据库系统仍然具有持久性语义。

- 在那些受操作影响的缓存页被同步到磁盘之前，将所有操作持久化到磁盘。每个修改数据库状态的操作必须先写日志到磁盘上，然后才能修改相关页的内容
- 当发生崩溃时，使系统可以从操作日志中重建内存中丢失的更改。通过重放日志便可以恢复未提交的数据，使得数据库可以完全恢复到崩溃前的状态。



# 参考资料

1. 数据库系统内幕
