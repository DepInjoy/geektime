事务是指数据库中一个不可分的逻辑工作单元，它允许将多个操作表示为一个步骤。数据库事务必须遵从原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)和持久性(Durability)，这些属性通常合称为ACID：
1. 原子性，事务的步骤是不可分的，这意味着，事务中的所有步骤要么全都执行成功，要么全都不执行。换句话说，事务不应当被部分应用。每个事务要么成功提交(使事务内写操作产生的所有更改变得可见)，要么中止(回滚所有尚不可见的事务副作用)。提交是事务的最后一个操作。中止后可以重试该事务。
2. 一致性，一种特定于具体应用的保证：事务只能将数据库从一个有效状态带到另一个有效状态，并保持所有的数据库不变量(比如约束、引用完整性等)。一致性是定义最弱的属性，可能因为它是唯一一个由用户控制而不是仅凭数据库自身保证的属性。
3. 隔离性，多个并发执行的事务应该能够互不干扰地运行，每个事务都像没有其他事务在同时执行一样。隔离性定义了何时以及哪些对数据库状态的更改可以对并发事务可见。出于性能原因，许多数据库使用的隔离级别要弱于这里给出的隔离性定义。根据并发控制的实现，一个事务所做的更改可能对其他并发事务可见或不可见。
4. 持久性，一旦事务被提交，所有数据库状态的修改都必须被持久化到磁盘上，即使之后发生断电、系统故障或崩溃也不受影响。

事务处理器分成两个主要部分：

- **并发控制管理器或调度器**，负责保证事务的原子性(Atomicity)和隔离性(Isolation)。
- **日志和恢复管理器**，负责事务的持久性(Durability)。



# 组件和职责

事务管理器从应用系统接受事务命令，从而得知什么时候事务开始，什么时候事务结束。事务处理器执行下面的任务：

1. **日志记录**。为了保证持久性，对于数据库的每一个变化都在磁盘上记录日志。**日志管理器**遵循某几种策略中的某一种工作，这些策略保证任何时候系统发生故障或崩溃，**恢复管理器**都可以查看关于数据库变化的日志，并将数据库恢复到某个一致的状态。开始时，日志管理器将日志写到缓冲器，它与缓冲区管理器协调，保证在适当的时候将缓冲区写到磁盘。

2. **并发控制**。调度器(并发控制管理器)保证多个事务的一个个动作以一种适当的顺序执行，从而是的最终的结果与这些事务事实上一个执行完再执行下一个动作结果相同。典型的调度器通过在数据库的某些部分上维护若干个锁来工作。这些锁防止两个事务造成不良后果的方式存取数据库的相同部分。锁通常存储在主存储器的**锁表**中，调度器禁止执行引擎访问数据库中被封锁的部分，从而对查询和其他数据库操作的执行产生产生影响。

3. **死锁解决**。事务之间通过调度器所授予的锁进行资源竞争时，可能会进入这样的情况：没有任何一个事务可以进行下去，因为任何一个事务都需要另一个事务所持有的某个资源。事务管理器有责任进行干预，取消(回滚)一个或多个事务，从而让其他的事务可以进行下去。



事务处理器分成两个主要部分：并发控制管理器或调度器，负责保证事务的原子性和孤立性；日志和恢复管理器，负责事务的持久性。数据库系统中实现事务需要多个组件协同工作。

1. 事务管理器负责协调、调度和跟踪事务及事务的各个步骤。
2. 锁管理器可保护对资源的访问，并防止那些可能破坏数据完整性的并发访问。每当请求加锁时，锁管理器会检查这个锁是否已被其他事务以共享或排他模式持有，如果请求的访问级别没有冲突则允许本次访问。由于排他锁在任意时刻最多只能被一个事务持有，所以其他请求加锁的事务必须等待锁被释放，或者中止事务并稍后重试。一旦锁被释放或事务终止，锁管理器就会通知其中一个挂起的事务，让它获得锁并继续执行。
3. 页缓存充当了持久性存储(磁盘)和存储引擎其余部分之间的中介。它将状态更改暂存在内存中，同时也用于缓存那些尚未与持久性存储同步的页。一切数据库状态的更改都首先被应用在缓存的页上。
4. 日志管理器记录了已应用在缓存页上的操作(日志条目)，这些操作尚未与持久性存储同步，而日志可以确保这些操作不会在崩溃时丢失。换句话说，在数据库启动期间，利用日志来重新应用这些操作并重建缓存状态。日志条目也可以用来撤销已中止的事务所做的更改。
5. 分布式(多分区)事务需要额外的协调机制以及远程执行。

# 页缓存

大多数数据库都采用双层存储体系：较慢的持久性存储(磁盘)和较快的主内存(RAM)。为了减少对持久性存储的访问次数，页面被缓存在内存中。当存储层再次请求该页时，将返回其缓存副本。假设没有其他进程修改磁盘上的数据，则内存中的缓存页可以被重用，这种做法有时也称为<b><font color=FA8072>虚拟磁盘</font></b>。仅当内存中没有页副本可用时，对虚拟磁盘的读取才会访问物理存储，很多时候，称上述机制为<b><font color=FA8072>页缓存或缓冲池</font></b>。页缓存负责缓存从磁盘读取的页，如果数据库崩溃或意外关闭，则缓存的内容将丢失。其中，<b><font color=FA8072>将未缓存的页从磁盘加载进来的过程称为换入(page in)。</font></b>缓存的页一旦被更改过就成了脏页，直到这些更改被刷写(flush)到磁盘上。由于页缓存的内存区通常比整个数据集小得多，所以页缓存终究会被填满。<b><font color=FA8072>为了换入新页，必须将其中某个页换出(evict)缓存。</font></b>

操作系统同样具有页缓存的概念，操作系统将空闲的内存段用来透明地缓存磁盘内容，以提高I/O系统调用的性能。

> 绕过内核的页缓存
> 很多数据库系统使用O_DIRECT标志打开文件。该标志允许I/O系统调用绕过内核的页缓存直接访问磁盘，并使用数据库专用的缓冲区管理。
>
> Linus Torvalds批评过O_DIRECT的使用，因为它不是异步的，而且没有预读之类的方法来告知内核有关访问模式的信息。但是，在操作系统提供更好的机制之前，O_DIRECT仍然很有用。
>
> 可以通过fadvise这个系统调用从某种程度上控制内核如何将页换出页缓存，但这仅仅是让内核考虑我们的意见，并不保证它一定会发生。为了避免在执行I/O时发生系统调用，可以使用内存映射，但那样我们也失去了对缓存的控制。

页缓存的主要功能：

- 在内存中保留被缓存的页的内容。
- 把对磁盘页的修改缓冲起来，并且修改的是缓存的版本。
-  当被请求的页不在内存中且可用空间足够时，页缓存会将其换入并返回缓存的版本。
-  如果请求的页在缓存中，则直接返回缓存的版本。
-  如果可用空间不足以放下新的页，则某些其他页会被换出，被换出的页的内容会被刷写回磁盘。



## 缓存语义

所有对缓冲区的更改都保留在内存中，直到最终被写回到磁盘上。由于不允许任何其他进程修改磁盘上的这些文件，所以这个<b><font color=FA8072>同步过程是单向的：只能从内存同步到磁盘</font></b>，而不能反过来进行。页缓存让数据库能够更好地控制内存管理和磁盘访问，可以将它视作内核页缓存在应用程序中的等效实现：它直接访问块存储设备，实现类似的功能，也达到了类似的目的。它是<b><font color=FA8072>对磁盘访问的抽象，并将逻辑写操作与物理写操作分离。页缓存使得可以将树部分保留在内存中，而无须修改算法本身或是在内存中物化对象，我们要做的仅是把磁盘访问替换成对页缓存的调用。</font></b>

当存储引擎访问(或请求)页时，我们首先检查其内容是否已被缓存。如果该页在缓存中，则直接返回缓存的页。如果该页未被缓存，则页缓存会将其逻辑地址或页号转换为物理地址，并将它的内容加载到内存，然后返回已缓存的版本给存储引擎。一旦返回，这个存有缓存页内容的缓冲区就称为<b><font color=FA8072>被引用的(referenced)</font></b>，存储引擎必须在用完之后将其归还给页缓存或<b><font color=FA8072>解除引用</font></b>。若想让页缓存不要换出某些页，则可以将它们<b><font color=FA8072>固定(pin)</font></b>。如果某个页被修改了(例如追加了一个新的单元格)，则该页被标记为<b><font color=FA8072>脏页，页上的脏标志位表示其内容与磁盘不同步，必须将其刷写到磁盘上才能保证持久.</font></b>



## 缓存回收

保持缓存填满的状态是件好事：这可以让更多的读请求无须经过持久性存储，也让同一页上更多的修改能被缓冲在一起。但页缓存的容量毕竟是有限的，迟早会用尽所有空间，彼时为了放下新内容只能换出旧页。如果页的内容与磁盘是同步的(已刷写过或从未修改过)，并且该页面未被固定或引用，则可以立即将其换出。脏页则必须在刷写之后才能换出。如果页正在被其他线程使用，则不能将其换出。

如果每次换出页都刷写磁盘，则其性能可能会很差。因此某些数据库使用单独的后台进程，该进程循环检查可能被换出的脏页，更新其磁盘上的版本。例如，PostgreSQL中的一个后台刷写器就是用来做这件事情的。另一个重要属性是持久性：如果数据库崩溃，则所有未刷写的数据都会丢失。为了确保所有更改都被持久化，检查点进程会协调刷写进程。检查点进程控制预写日志(WAL)和页缓存，并确保两者协同工作。只有当缓存页完成刷写之后，相关操作的日志记录才能从WAL中丢弃。在上述过程完成后才能将脏页换出缓存。

这意味着需要在多个目标间做一些权衡：

- 推迟刷写以减少磁盘访问次数。
- 提早刷写以让页能被快速地换出。
-  选择要换出的页，并以最优的顺序刷写。
-  将缓存大小保持在其内存范围内。
-  避免因数据没有被持久化到主存储中而丢失它们。



## 缓存锁定页

每次读取或写入都进行磁盘I/O是不切实际的：并发的读取可能会请求同一页，并发的写入也可能会修改同一页。由于B树越靠近顶部越窄，所以层次较高的节点(靠近根的节点)在大多数读取中都会被命中。分裂与合并操作最终也会传播到较高层次的节点，这意味着至少树的某一部分一定会受益于缓存。<b><font color=FA8072>锁定那些在近期大概率会被用到的页。在缓存中锁定页的操作称为固定，被固定的页会在内存中保留更长的时间，这有助于减少磁盘访问次数并提高性能。</font></b>在B树上，随着节点层次的降低，每层的节点数量呈指数级增加，并且较高层次的节点仅占整棵树的一小部分，因此这部分节点可以永久驻留在内存中，而其他部分则可以按需换入。这意味着，在执行一次查询时我们不必进行h(树的高度)次磁盘访问，只有在访问那些未被缓存的低层页时才会真正读取磁盘。

针对子树执行的操作可能会导致相互矛盾的结构变化，例如：多次删除操作导致节点合并，随后写入又导致分裂，或者相反。从不同子树传播上来的结构变化亦是如此(结构变化的发生时间很接近，但是发生在树的不同部分，并向上传播)。通过仅在内存中应用更改，可以将这些操作缓冲在一起，从而减少磁盘写入的次数并分摊写入成本，因为只要做一次磁盘写入即可，无须写入多次。

> 预取和立即换出缓存
>
> <b><font color=FA8072>页缓存也允许存储引擎对预取和换出进行细粒度的控制，存储引擎可以指示页缓存在访问页之前提前加载页。</font></b>例如，当在范围扫描中遍历叶节点时，可以预加载下一个叶节点。同样，如果后台维护进程加载了某个页，则可以在进程完成后立即将其换出缓存，因为它不太可能被进行中的查询用到。某些数据库(例如PostgreSQL)使用循环缓冲区(即先进先出的页置换策略)进行大规模顺序扫描。



## 页置换

当缓存容量用完时，为了加载新页，必须换出旧页。但是，除非我们换出近期不太可能再次访问的页，否则这些页可能会反复加载多次。为了优化该行为，我们需要找到一种方法来估计后续页被访问的可能性。为此，我们应当根据换出策略(有时也称为页置换策略)将页换出，该策略尝试找出近期最不可能被再次访问的页。当这个页被换出后，新页可以加载到它的位置上。为了实现高效的页缓存，我们需要一种有效的页置换算法，使用正确的页置换策略也能帮助减少换出的次数。

使用更大的缓存能够帮助我们减少换出的次数，这听起来似乎很合理，但事实并非如此。可以说明这种困境的例子之一是<b><font color=FA8072>B閘醖y异常[BEDALY69]</font></b>。它表明，如果使用的页置换算法不是最优的，则增加页数可能导致换出的次数增加。当很快可能会用到的页被换出缓存然后又被再次加载时，页将开始争夺缓存中的空间。



### FIFO和LRU

最简单的页置换策略是先进先出（FIFO）。FIFO按插入顺序维护一个页ID的队列，将新页添加到队列尾部。每当页缓存已满时，FIFO从队列头部取出元素，这也就是最早被换入的页。由于它不考虑后续的页访问，而是仅考虑页换入时间，所以该策略对于大多数真实系统而言是不切实际的。例如，根节点和最上层节点的页最先被换入，根据此算法，这些页也会被最先换出缓存，尽管从树结构中能明显看出这些页很快就会被再次换入。

对FIFO算法的自然扩展是最长时间未使用策略(LRU)，LRU也按插入顺序维护一个换出候选队列，但是当重复访问某个页时，LRU会将其放回队列尾部，就像首次换入时那样。然而，并发环境下每次访问都要更新引用和重新链接节点可能代价较高。

此外还有一些基于LRU的缓存换出策略。例如，

- `2Q`（双队列LRU）维护两个队列，在初次访问时放入第一个队列，在后续访问时将它们移入第二个热队列，从而区分最近访问的页和经常访问的页。
- `LRU-K`通过跟踪最近的K次访问来识别频繁用到的页，并使用此信息来估计访问时间



### CLOCK

CLOCK算法变体常常被用作LRU的一种更加紧凑、更加缓存友好且并发性更好的替代品。例如，Linux使用CLOCK算法的一种变体。CLOCK-sweep算法将页的引用和与之关联的访问位保存在环形缓冲区中。一些变体使用计数器而不是比特位来描述频率。每当访问某个页面时，都将它的访问位设置为1。CLOCK算法的工作原理是循环检查环形缓冲区上的访问位：

- 如果访问位为1且该页未被引用，则将其置为0并检查下一页。
-  如果访问位已经为0，则将该页作为一个要换出的候选，并安排在后续将其换出。
-  如果页当前正被引用，则它的访问位保持不变。算法假定被访问页的访问位不可为0，因此不会被换出缓存，这使得被引用的页更不可能被置换。

使用环状缓冲区的一个优点是：时钟指针和缓冲区内容都可以用比较-置换(CAS)原子操作来修改，无须额外的加锁机制。该算法很容易理解和实现。



### LRU

LRU并非对于所有数据库来说都是最佳的置换策略。有时，考虑将使用频率而非最近使用时间作为预测因子可能更贴合实际。最后，对于负载很重的数据库系统，最近使用时间可能不太具有参考性，因为它只表示项目被访问的顺序。为了改善这一情况，追踪页引用事件而不是页换入事件。其中一种实现是跟踪具有最小使用频率(LFU)的页。

TinyLFU是一种基于频率的页置换策略：TinyLFU不根据页换入的时间来换出页，而是根据使用频率对页进行排序。使用频率直方图来维护一个紧凑的缓存访问历史记录，因为出于实用性考虑，保存完整历史记录的代价太高。元素可能位于以下三个队列中的某一个：

- 入场(admission)队列：维护新加入的元素，用LRU策略实现。
- 考察(probation)队列：其中的元素最有可能被换出缓存。
-  保护(protected)队列：其中的元素将在队列中保留更长的时间。

TinyLFU不是选择要换出哪些元素，而是选择要保留的元素。访问频率相对较高的元素会被晋升到考察队列中。在后续访问中，元素可以从考察队列移至保护队列。如果保护队列已满，则必须将其中某个元素放回考察队列。经常访问的元素有较高的机会被保留，而不经常访问的元素则更有可能被换出缓存。

# 并发控制

事务管理器和锁管理器协同工作以处理并发控制。并发控制是一组用于处理并发事务间交互的技术，在技术实现上可以分为三大类

1. 乐观并发控制(OCC)，<b><font color=FA8072>允许多个事务执行并发的读取和写入操作，最后确定其执行结果能否被串行化</font></b>(serializable)。换句话说，事务不会彼此阻塞，而是保留其操作历史，并在提交前检查这些历史操作是否存在冲突的可能。如果会产生冲突，则中止其中某一个冲突的事务。

2. 多版本并发控制(MVCC)允许一条记录同时存在多个时间戳的版本，通过这种方式<b><font color=FA8072>保证事务读到的是数据库过去某个时刻的一致视图</font></b>。MVCC可以使用验证技术来实现，即只允许多个更新或事务提交中的某一个获胜，也可以使用无锁技术(例如时间戳排序)或基于锁的技术(例如两阶段锁)。

3. 悲观并发控制，也称为保守并发控制(PCC)，既有基于锁的实现，也有不加锁的实现，它们的主要区别在于如何管理和授权对共享资源的访问。

   - 基于锁的实现要求事务维护数据库记录上的锁，以防止其他事务修改被加锁的记录或访问当前事务正在修改的记录，直到锁被释放为止。
   - 不加锁的实现根据未完成事务的调度，维护读取与写入的操作列表以限制事务的执行。

   <b><font color=FA8072>悲观的调度可能导致死锁：多个事务需要互相等待对方释放锁才能继续执行</font></b>。

讨论并发控制前，首先明确要解决的问题集，并讨论事务操作会以怎样的方式重叠以及重叠会产生什么样的后果。



## 可串行化

事务包括对数据库状态的一系列读取和写入操作以及业务逻辑。调度(schedule)是指数据库视角上执行一组事务所需的操作列表(即仅包含与数据库状态交互的操作，例如读、写、提交和中止)，因为我们假定其他所有的操作不影响数据库状态。

如果一个调度中包含其中每个事务的所有操作，则称它是完整的。一个正确的调度在逻辑上等效于原始操作列表，但是可以并行执行其中某些部分，也可以出于优化目的对其进行重新排列，只要不违反ACID性质并保证各事务的结果正确即可。

如果一个调度中的事务完全独立且无交错地执行，则我们称它为串行的调度：每个事务在下一个事务开始之前已完全执行。相比于多个事务的各种交错执行，串行执行很容易进行论证。但是，总是一个接一个地执行事务将会大大限制系统吞吐量并损害性能。我们需要找到一种方法，它能够并发执行事务操作，同时保持串行调度的正确性和简单性。可串行化的调度可以满足这一要求。<b><font color=FA8072>如果一个调度等效于同一组事务的某一完整串行调度，则该调度是可串行化的。</font></b>换句话说，它产生的结果与我们以某种顺序一个接一个地执行一组事务的结果相同。



## 隔离级别

<b><font color=FA8072>隔离级别指定了事务的各部分如何以及何时可以被其他事务看到。</font></b>换句话说，隔离级别描述了将事务与其他并发事务隔离的程度以及执行过程中可能发生哪些种类的异常(anomaly)。实现隔离需要付出一定的代价：为了防止其他事务读到不完整或临时的写入，我们需要额外的协调和同步机制，而这会对性能产生负面影响。



SQL标准描述了执行并发事务期间可能发生的<b><font color=FA8072>读异常：脏读(dirty read)、不可重复度(nonrepeatable  read，也称为模糊读fuzzy read)和幻读</font></b>。

| 读异常     | 概念                                                         | 示例描述                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 脏读       | 一个事务能读到其他事务未提交的更改                           | 事务T1更新了一条用户记录的地址字段<br/>事务T2在T1提交前就读到了已被更新的地址 |
| 不可重复读 | 也称为模糊度(fuzzy read)，同一事务两次查询同一行却得到不同的结果。 | 事务T1读取一行，然后事务T2修改该行并提交了这一更改。如果T1在完成执行之前再次查询同一行，则结果将会和前一次查询不同。 |
| 幻读       | 事务两次查询同样的行集合却得到不同的结果。它与不可重复读类似，但仅适用于范围查询。 |                                                              |

也存在具有类似语义的写异常：丢失更新(Lost Update)，脏写和写偏斜。

| 写异常   |                                                              | 示例描述                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 丢失更新 | 发生在事务T1和T2同时尝试更新V的值时。T1和T2读取V的值。T1更新V并提交，之后T2也更新V并提交。由于这两个事务不知道彼此的存在，所以如果允许二者都提交，则T1的结果将被T2的结果覆盖，T1的更新。 |                                                              |
| 脏写     | 某个事务拿到了一个未提交的值(即脏读)，对其进行修改并保存<br/>也就是说，事务结果来自从未提交过的值。 |                                                              |
| 写偏斜   | 各个单独的事务都遵守要求的约束，但它们的组合却违反了这些约束。 | 事务T1和T2修改两个账户A1和A2的值。最初A1有100元，A2有150元。<br/>账户的值可以为负，只要两个账户之和为非负数就行，即要满足A1+A2≥0。<br/>T1和T2分别尝试分别从A1和A2取出200元。在两个事务开始时，A1+A2=250元，因此共有250元可用。两个事务都认为它们没有违反约束，可以提交。提交后，A1为-100元，A2为-50元，这显然违反了账户之和为非负数的要求 |



隔离级别和允许的异常

|          隔离级别          |  脏读  | 不可重复读 |  幻读  |
| :------------------------: | :----: | :--------: | :----: |
| 读未提交(read uncommitted) |  允许  |    允许    |  允许  |
|  读已提交(read commited)   | 不允许 |    允许    |  允许  |
| 可重复读(repeatable read)  | 不允许 |   不允许   |  允许  |
| 可串行化(serializability)  | 不允许 |   不允许   | 不允许 |



ACID中的隔离性意味着可串行化，实现可串行化需要协调，也就是说，并发执行的事务必须进行协调以确保遵守约束，并在发生冲突时强加某一串行顺序。一些DB采用快照隔离，在<b><font color=FA8072>快照隔离(snapshot isolation)中，一个事务可以观察到所有在该事务开始前已提交的事务所做的状态更改。</font></b>每个事务都会获取一个数据快照，并在快照上执行查询。快照在事务执行期间不会发生变化。只有当事务中修改的值没有被其他事务修改时，才可以提交事务，否则它将被中止并回滚。

- 如果两个事务试图修改同一个值，则只有其中一个事务能够提交，这会防止丢失更新异常。例如，事务T1和T2都尝试修改V。它们从快照读取V的当前值。首先尝试提交的事务会成功提交，而另一个事务则必须中止。失败的事务将会重试，而不是覆盖已修改的值。
- <b><font color=FA8072>快照隔离中可能发生写偏斜异常</font></b>：如果两个事务分别读取本地状态、修改不同的记录并且遵守本地的约束。

# 恢复管理

预写日志(Write-Ahead Log，WAL，也称为提交日志)是一种仅追加的辅助磁盘数据结构，用于崩溃和事务的恢复。页缓存允许我们在内存中缓冲对页面内容的更改，而在将缓存的内容刷写回磁盘之前，WAL是保留操作历史的唯一磁盘副本。许多数据库系统使用仅追加的预写日志，例如PostgreSQL和MySQL。预写日志的主要功能可以概括为：

- 在允许页缓存将页上的修改缓存起来的同时，保证数据库系统仍然具有持久性语义。

- 在那些受操作影响的缓存页被同步到磁盘之前，将所有操作持久化到磁盘。每个修改数据库状态的操作必须先写日志到磁盘上，然后才能修改相关页的内容
- 当发生崩溃时，使系统可以从操作日志中重建内存中丢失的更改。通过重放日志便可以恢复未提交的数据，使得数据库可以完全恢复到崩溃前的状态。

WAL确保将数据存储到持久性存储中，即使发生崩溃也依然可用：通过重放日志便可以恢复未提交的数据，这样数据库就可以完全恢复到崩溃前的状态。ARIES(Algorithm for Recovery and Isolation Exploiting Semantics，一种利用语义的恢复和隔离算法)，这是一种先进的、被广泛使用和引用的算法。



## 日志语义

<b><font color=FA8072>预写日志是仅追加的，并且已写入的内容是不可变的，因此所有对日志的写入都是顺序的。WAL由日志记录组成，每条记录都有一个唯一的、单调递增的日志序列号(LSN)。</font></b>通常，LSN由一个内部的计数器或时间戳表示。日志记录不一定占据整个磁盘块，其内容会被缓存在日志缓冲区中，并在强制刷盘(force)操作时被刷写到磁盘上。强制刷盘操作发生在日志缓冲区被填满时，也可能被来自事务管理器或页缓存的请求所触发。各日志记录必须以LSN的顺序刷写到磁盘上。除了单独的操作记录外，WAL还会保存事务完成的记录。只有当事务提交记录完成刷盘之后，才能将该事务视为已提交。

系统在回滚或恢复期间也有可能发生崩溃，为了确保这种情况下系统能继续正常工作，某些系统会在撤销操作时记录补偿日志记录(CLR)并将其存储在日志中。

WAL通常与主存储结构紧密耦合，它提供了允许在到达检查点时对其进行修剪(trim)的接口。日志修剪与确保数据已到达主存储结构之间细微的不一致都可能导致数据丢失。

<b><font color=FA8072>检查点使得我们知道某个特定标记之前的日志记录都已被持久化且不再需要了，大大减少了数据库启动过程中的工作量。</font></b>强制将所有脏页刷写到磁盘上的过程通常称为同步检查点(sync checkpoint)，因为它完全同步了主存储结构。把全部内容刷写到磁盘上是不现实的，而且需要暂停所有正在运行的操作，直到检查点完成。因此大多数数据库都实现了<b><font color=FA8072>模糊检查点(fuzzy checkpoint)</font></b>，在这种情况下，日志头部的last_checkpoint指针记录了最后一次成功的检查点信息。模糊检查点以特殊的begin_checkpoint日志记录开始（标志着检查点的开始），结束于end_checkpoint日志记录，其中包含脏页的信息以及事务表的内容。在刷写完该记录中提到的所有页之前，检查点都被视为不完整的。页是异步刷新的，一旦完成，last_checkpoint指针将被更新为begin_checkpoint日志记录的LSN，如果发生崩溃，则恢复过程将从此处开始。



## 操作日志和数据日志

System R使用影子页(shadow paging)——一种写时复制(copy-on-write)技术，来确保数据持久性和事务原子性。新内容被存放在一个新的、未发布的影子页中，并通过指针翻转使其可见，从旧页切换到包含更新内容的新页。任何状态变化都可以由前像(before-image)和后像(after-image)或相应的重做(redo)和撤销(undo)操作表示。对前像应用重做操作会生成后像，类似地，对后像应用撤销操作会产生一个前像。

我们可以<b>使用物理日志(保存对完整页状态或字节级的更改)或逻辑日志(保存在当前状态上执行的操作)将数据记录或页从一个状态变成另一个状态</b>，无论是正向还是逆向。另一个很重要的事情是，我们必须记录下在应用这些物理日志或逻辑日志之前页的确切状态。物理日志记录了前像和后像，受操作影响的整个页都要被记录下来。逻辑日志记录了要对页应用哪些操作，例如，向键Y插入数据记录X，以及相应的撤销操作，例如，删除与Y关联的值。

在实践中，许多数据库结合使用上述两种方法：<b><font color=FA8072>使用逻辑日志记录执行撤销操作(以提升并发)，使用物理日志记录执行重做操作(以缩短恢复时间)</font></b>。



## steal和force策略

为了确定应何时将内存中的更改刷写到磁盘上，数据库定义了steal/no-steal和force/no-force策略。

- 在事务提交之前允许刷写事务修改过的页，这被称为steal策略。而no-steal策略不允许将未提交的事务内容刷写到磁盘。之所以称为steal策略，是因为它将脏页偷窃（steal）出来，将其中的内容刷写到磁盘上，并从磁盘加载另一个页到该位置。
- force策略要求在事务提交前将事务修改的所有页刷写到磁盘上。而在no-force策略中，即使事务修改的某些页尚未刷写到磁盘上，该事务也可以提交。这里force的含义是强制（force）脏页在事务提交前必须将其刷写到磁盘上。

理解steal和force策略非常重要，因为它们会影响事务的撤销和重做。

- 若使用no-steal策略，那么只需要重做日志就可以实现恢复：旧副本包含在磁盘的页上，而修改被存储在日志中。若使用no-force策略，我们就可以通过推迟对页的若干个更新来缓冲它们。由于这段时间内必须将页缓存在内存中，所以可能需要一个更大的页缓存。
- 使用force策略时，崩溃恢复无须任何其他工作即可重建已提交事务的结果，因为这些事务修改的页都已被刷写到磁盘。该方法的主要缺点是，由于在事务提交中必须要进行I/O操作，所以提交时间更长。

更一般地说，直到事务提交前，我们需要保存有足够的信息来撤销它的结果。<b><font color=FA8072>如果事务中涉及的页都已经刷写到磁盘，那么需要在日志中保留撤销信息，以在事务提交之前确保它能被回滚；否则，必须保留重做日志。在这两种情况下，只有当撤销或重做记录被写入日志文件后，事务才能提交。</font></b>

## ARIES

# 参考资料

1. 数据库系统内幕
