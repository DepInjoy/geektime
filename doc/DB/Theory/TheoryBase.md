# 模型与语言

# 数据模型
数据模型是对现实世界数据特征的抽象，分两类：
- 概念模型也称信息模型
- 逻辑模型和物理模型，逻辑模型主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等。按计算机系统的观点对数据建模，用于DBMS实现。 物理模型是对数据最底层的抽象，描述数据在系统内（磁盘上）的表示方式和存取方法。

## 组成要素
- 数据结构--描述系统的静态特性
- 数据操作--描述系统的动态特性
- 完整性约束

# 关系模型
| 人  | 事  | 物  | 理  |
|--- | --- | --- | --- |
|E.F.Codd最早提出|E.F.Codd在1970年提出, 从表(Table)及表的处理方式中抽象出来的, 是在对传统表及其操作进行数学化严格定义基础上，引入集合理论与逻辑学理论提出的| 现在大多数商品化数据库系统使用的数据模型还是关系模型，例如MySQL、Oracel等|关系模型是数据库的三大经典数据模型之一, 标准的数据库语言(SQL语言)是建立在关系模型基础之上的, 数据库领域的众多理论也都是建立在关系模型基础之上的</br>|

关系模型研究内容:
> 一个关系(relation)就是一个Table。关系模型就是处理Table的，它由三个部分组成：
> - 描述DB各种数据的基本结构形式(Table/Relation) -- **Table如何描述**
> - 描述Table与Table之间所可能发生的各种操作(关系运算) -- **有哪些操作,结果是什么？**
> - 描述这些操作所应遵循的约束条件(完整性约束) -- **有哪些约束**

## 关系模型三要素
### (一) 基本结构：Relation/Table
关系(Relation)
- 一组域$D_{1}, D_{2}, …, D_{n}$的笛卡尔积的子集
- 笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)
- 由于关系不同列可能来自同一个域，为了区分，为每一列起一个名字，该名字即为属性名。

关系可用$R(A_{1}:D_{1} , A_{2}:D_{2}, … ,A_{n}:D_{n})$表示，可简记为$R(A_{1} , A_{2}, … , A_{n})$，这种描述又称为关系模式(Schema)或表标题(head)。其中
- $R$是关系名, $A_{i}$是属性, $D_{i}$是属性所对应的域
- $n$是关系的度或目(Degree), 关系中元组的数目称为关系的基数(Cardinality)

关系模式$R(A_{1}:D_{1} , A_{2}:D_{2}, … ,A_{n}:D_{n})$中属性向域的映象在很多DBMS中一般直接说明为属性的类型、长度等。例如：
```sql
Student(S# char(8), Sname char(10), Ssex char(2), Sage integer,
        D# char(2), Sclass char(6) )
```

关系模式与关系
- 同一关系模式下，可有很多的关系
- 关系模式是关系的结构, 关系是关系模式在某一时刻的数据
- 关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的


### (二) 基本操作：Relation Operator 

基本操作有
$$
\begin{array}{l}
\cup(并集, UNION) \\
\ - (差集,DIFFERENCE) \\
\times(广义积) \\
\sigma (选择，SELECTION) \\
\pi (投影,PROJECTION)\\
\end{array}
$$

扩展操作有
$$
\begin{array}{l}
\cap (交,INTERSECTION) \\
\Join (连接,JOIN) \\
\div (除，DIVISION) \\
\end{array}
$$

### (三) 完整性约束
- 1. 实体完整性：关系的主码中的属性值不能为空值
> 空值：不知道或无意义的值, 数据库中有了空值，会影响许多方面, 如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等. 
> 
> 意义：关系中的元组对应到现实世界相互之间可区分的一个个个
体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识
的个体，不容许的。
- 2. 参照完整性：如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk值, 或者为空值
> 意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在
- 3. 用户自定义的完整性：用户针对具体的应用环境定义的完整性约束条件。例如性别只能是男或女。

其中，实体完整性和参照完整性属于关系的两个不变性. DBMS对关系完整性的支持
- 实体完整性和参照完整性由DBMS系统自动支持
- DBMS系统通常提供了如下机制：
  - 1. 它使用户可以自行定义有关的完整性约束条件
  - 2. 当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性

## 关系

### 关系特性

- **列是同质：即每一列中的分量来自同一域，是同一类型的数据。**

- **不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。** 关系模式$R(A_{1}:D_{1} , A_{2}:D_{2}, … ,A_{n}:D_{n})$中，$A_i(i=1...n)$必须是不同的，而$D_i(i=1...n)$可以是相同的。
- **列位置互换性**：区分哪一列是靠列名
- **行位置互换性**：区分哪一行是靠某一或某几列的值(关键字/键字/码字)
- **关系是以内容来区分的，而不是属性在关系的位置来区分**
- 理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。
- 元组相同是指两个元组的每个分量都相同
- **属性不可再分特性**:又被称为关系第一范式

### 关系相关概念
#### 1、候选码(Candidate Key)/候选键

> 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。
> 
> 例如: 选课`(S#, C#, Sname, Cname, Grade)`，`(S#,C#)`联合起来是一个候选码

#### 2、主码(Primary Key)/主键
> 当有多个候选码时，可以选定一个作为主码。 DBMS以主码为主要线索管理关系中的各个元组。

#### 3、主属性与非主属性
> 包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性
> 
> 例如:选课`(S#, C#, Sname, Cname, Grade)`，`S#`和`C#`为主属性，而`Sname, Cname, Grade`则为非主属性
> 
> 最简单的，候选码只包含一个属性。
> 最极端的，所有属性构成这个关系的候选码，称为全码(All-Key)。
#### 4、外码(Foreign Key)或外键
> 关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。
> 
> 例如，“合同”关系中的客户号不是候选码，但却是外码。与“客户”关系中的候选码“客户号” 相对应。
> 两个关系通常是靠外码连接起来的。
## 关系代数

### 基本操作
关系代数运算的约束：
某些关系代数操作，如并、差、交等，需满足“并相容性”
> 并相容性：参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义
关联性.
> 
> 定义：关系R与关系S存在相容性，当且仅当：
> - (1) 关系R和关系S的属性数目必须相同
> - (2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同
>
>假设：$R(A_{1}, A_{2}, … , A_{n})$ , $S(B_{1}, B_{2}, … ,B_{m})$
$R$和$S$满足并相容性：$n = m$ 且 $Domain(A_{i}) = Domain(B_{i})$


#### 并(Union)操作
> 定义：假设关系$R$和关系$S$是并相容的，则关系$R$与关系$S$的并运算结果也是一个关系，记作：$R \cup S$, 它由或者出现在关系R中，或者出现在S中的元 组构成。
> 
> 数学描述：
$$ 
\begin{array}{l}
R \cup S = \{t | t \in R \vee t \in S \}\\
其中，t是元组
\end{array} 
$$
> 并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。 
> $R \cup S$与$S \cup R$运算的结果是同一个关系


#### 差(Difference)操作
> 定义：假设关系$R$和关系$S$是并相容的，则关系$R$与关系$S$的差运算结果
也是一个关系，记作：$R -S$, 它由出现在关系R中但不出现在关系S中的元组构成。
> 
> 数学描述:
$$
\begin{array}{l}
R-S = \{t | t \in R \wedge  t \notin S \}\\
其中，t是元组
\end{array} 
$$
> $R-S$ 与$S-R$是不同的


#### 笛卡尔积(Cartesian Product)操作
> 定义：关系$R (<a_{1} , a_{2}, …, a_{n}>)$ 与关系$S(<b_{1}, b_{2}, …, b_{m}>)$ 的广义笛卡尔积(简称广义积, 或积, 或笛卡尔积) 运算结果也是一个关系，记作：$R \times S$, 它由关系$R$中的元组与关系$S$的元组进行所有可能的拼接(或串接)构成。
> 
> 数学描述:
$$
\begin{array}{l}
R \times S = \{<a_{1}, a_{2}, …, a_{n}, b_{1}, b_{2}, …, b_{m}> & | \\
<a_{1}, a_{2}, …, a_{n}> \in R \wedge <b_{1}, b_{2}, …, b_{m}> \in S\}
\end{array}
$$
- $R \times S = S \times R$
- 两个关系$R$和$S$，它们的属性个数分别为$n$和$m$($R$是$n$度关系，$S$是$m$ 度关系), 则笛卡尔积 $R \times S$ 的属性个数 = $n + m$。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量($R \times S$是$n+m$度关系).
- 两个关系$R$和$S$，它们的元组个数分别为$x$和$y$(关系$R$的基数$x$, $S$的基数$y$ ), 则笛卡尔积$R \times S$ 的元组个数 = $x  \times y$。($R \times S$的基数是$x \times y$).

#### 选择(Select)
定义：给定一个关系R, 同时给定一个选择的条件condition(简记con), 选
择运算结果也是一个关系，记作$\sigma_{con}(R)$, 它从关系R中选择出满足给定条件condition的元组构成。

数学描述
$$
\sigma_{con}(R) = \{t|t \in R \wedge con(t) = '真'\}
$$
- 设$R(A_{1} ,A_{2} , … ,A_{n})$, t是R的元组, t的分量记为$t[A_{i}]$, 或简写为$A_{i}$
- 条件con由逻辑运算符连接比较表达式组成
- 逻辑运算符：$\vee, \wedge, \neg$或写为$and, or, not$。
- 比较表达式：$X \theta Y$, 其中X, Y 是t的分量、常量或简单函数, $\theta$是比较运算符, $\theta \in {>, \ge, <, \le,  =, \ne }$

#### 投影(Project)
 定义：给定一个关系R, 投影运算结果也是一个关系，记作$\Pi_{A}(R)$, 它从
关系R中选出属性包含在A中的列构成。

数学描述:
$$
\begin{array}{l}
\Pi_{A_{i1}, A_{i2}, ... A_{ik}}(R) = \{<t[A_{i1}], t[A_{i2}], ... t[A_{ik}]> | t \in R\}
\end{array}
$$
- 设$R(A_{1} ,A_{2} , … ,A_{n})$
- ${A_{i1}, A_{i2}, … ,A_{ik}}$  \subseteq { A_{1} ,A_{2} , … ,A_{n}}$ 
- $t[A_{i}]$表示元组t中相应于属性$A_i$的分量
- 投影运算可以对原关系的列在投影后重新排列

**投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系**

### 扩展操作
#### 交(Intersection)
定义：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也
是一个关系，记作：$R \cap S$, 它由同时出现在关系R和关系S中的元组构成。

数学描述:
$$
R \cap S = \{t | t \in R \wedge t \in S \} \\
\\
其中：t是元组
$$

$R \cap S$ 和$S \cap R$运算的结果是同一个关系

交运算可以通过差运算来实现：$R \cap S = R - (R - S) = S - (S - R)$

#### $\theta$连接($\theta -Join$,  Theta-Join)
定义：给定关系R和关系S, R与S的连接运算结果也是一个关系，记
作$\underset{A \theta B}{R \Join S}$，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足条件的元组构成。

数学描述：
$$
\underset{A \theta B}{R \Join S} = \sigma_{t[A] \theta s[B]}(R \times S)
$$
- 设$R(A_{1}, A_{2} , … ,A_{n}), A \in { A_{1} ,A_{2} , … ,A_{n}}$
- $S(B_{1} ,B_{2}, … ,B_{m}), B \in {B_{1} ,B_{2}, … ,B_{m}}$
- t是关系R中的元组，s是关系S中的元组
- 属性A和属性B具有可比性
- $\theta$是比较运算符, $\theta \in {>, \ge, <, \le,  =, \ne }$

#### 等值连接(Equi-Join)
定义：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作$\underset{A = B}{R \Join S}$ ，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。

数学描述:
$$
\underset{A = B}{R \Join S} = \sigma_{t[A] = s[B]}(R \times S)
$$
- 当$\theta$-连接中运算符为“＝”时，就是等值连接，等值连接是-连接的一个
特例；
- 广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用$\theta$-连接/等值连接运算可大幅度降低中间结果的保存量，提高速度

#### 自然连接(Natural-Join)
定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作$R \Join S$ ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元
组所构成。

数学描述
$$
{R \Join S} = \sigma_{t[B] = s[B]}(R \times S)
$$
- 自然连接是一种特殊的等值连接
- 要求关系R和关系S必须有相同的属性组B(如R,S共有一个属性$B_{1}$,则B是$B_{1}$, 如R,S共有一组属性$B_{1}, B_{2}, …, B_{n}$，则B是这些共有的所有属性)
- $R,S$属性相同，值必须相等才能连接，即$R.B_{1} = S.B_{1} and R.B_{2}=S.B_{2} … and R.B_{n} = S.B_{n}$才能连接
- 要在结果中去掉重复的属性列(因结果中$R.B_{i}$ 始终是等于$S.B_{i}$ 所以可只保留一列即可)

### 复杂扩展操作

#### 除(Division)
除法运算经常用于求解“查询… 全部的/所有的…”问题

前提条件：给定关系$R(A_{1} ,A_{2}, …, A_{n})$为n度关系, 关系$S(B_{1}, B_{2}, …,B_{m})$为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集${B_{1}, B_{2}, …, B_{m}}$是属性集${A_{1}, A_{2}, …, A_{n}}$的真子集，即$m < n$

定义：关系R和关系S的除运算结果也是一个关系，记作$R \div S$，分两部分来定义,
- 先定义RS结果的属性应有哪些？设属性集$\{C_{1}, C_{2}, … ,C_{k}\} = \{A_{1}, A_{2}, …, A_{n}\} – \{B_{1}, B_{2}, …, B_{m}\}$, 则有k=n–m
则$R \div S$结果关系是一k度(n-m度)关系，由${C_{1}, C_{2}, … ,C_{k}}$属性构成
- 再定义$R \div S$的元组怎样形成？再设关系$R(<a_{1}, …, a_{n}>)$和关系$S (<b_{1}, …, b_{m}>)$, 那么$R \div S$结果关系为元组$<c_1, …, c_k>$的集合，元组$<c_1, …, c_k>$满足下述条件：它与S中每一个元组$<b_{1}, …, b_{m}>$组合形成的一个新元组都是R中的某一个元组$<a_{1}, …, a_{n}>$ 。(其中，$a_{1}, …, a_{n}, b_{1}, …, b_{m}, c_{1}, …, c_{k}$分别是属性$A_{1}, … , A_{n}, B_{1}, … ,B_{m} C_{1}, …, C_{k}$的值)

数学描述：
$$
\begin{array}{l}
{R \div S} = { t | t \in \Pi_{R-S}(R) \wedge \forall u \in S(tu \in R) }\\
= \Pi_{R-S}(R) - \Pi_{R-S}(\Pi_{R-S}(R) \times S) - R)
\end{array}
$$
#### 外连接
> 定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找
不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中
假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为
外连接(Outer Join)。

外连接 = 自然连接 (或连接) + 失配的元组(与全空元组形成的连接)
外连接的形式：左外连接、右外连接、全外连接
- 左外连接(Left Outer Join) = 自然连接(或连接) + 左侧表中失配的元组,记为$R \leftouterjoin S$
- 右外连接(Right Outer Join) = 自然连接(或连接) + 右侧表中失配的元组, 记为$R \rightouterjoin S$
- 全外连接(Full Outer Join) = 自然连接(或连接) + 两侧表中失配的元组, 记为$R \fullouterjoin S$
- 
## 关系演算