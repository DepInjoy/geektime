CTE复用 实际上就是让上游生成同一份的数据可以被多个下游多次消费。内核引擎中为了达到这个效果，主要需要处理下面两个问题：
1. 框架如何支持一个生产者对应多个消费者的拓扑。
2. 如何在算子级别实现生产者和消费者的有效管理, 以及避免死锁。

在MPP引擎中，从数据库内核的角度，对于优化器和计算引擎两个模块：
1. 优化器：如何发现CTE以及决策复用多少个CTE，如何描述一个生产者多消费者的DAG模型。
    1. 如何识别和表示CTE？这其中涉及
        - 子输出列顺序，类型和各层如何对齐？
        - 各个算子对应的物理实现算法？
        - 整个执行计划的拓扑结构(数据怎么传输，拓扑网络该怎么连边)?
    2. 判断 CTE-inline 和 CTE-Reuse 哪种方案更优？inline可能受益就可以给每个CTE部分做不同的优化，比如PredicatePushDown；CTE-Reuse的收益就是可以减少重复数据计算和IO；部分CTE复用
    3. 规避CTE-Reuse死锁。MPP引擎出现死锁的问题，本质上是<b>执行顺序拓扑</b>上出现了环行依赖。


2. 计算引擎： 主要解决如何具体实现消费者生产者的管理，如何做进度控制和内存效率以及调度框架如何调度这种DAG模型。

---

# 参考资料
1. [知乎：公共表达式CTE优化(Common Table Expression)](https://zhuanlan.zhihu.com/p/676644512)