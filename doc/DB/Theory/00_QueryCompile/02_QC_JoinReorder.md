目前流行的数据库中，针对join order选择普遍采用的算法包括动态规划算法、贪心算法、遗传算法等。比如pg和gp在表数目较少时采用了动态规划算法，表数目较多时采用遗传算法来解决该问题；而mysql则主要通过贪心算法来实现join order的选择。

| 比较方面           | 动态规划算法                                                 | 贪心算法                                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 依赖               | 依赖于有待做出的最优选择                                     | 依赖于当前已做出的所有选择                                   |
| 分析方法           | 自底向上                                                     | 自顶向下                                                     |
| 是否穷举join order | 是                                                           | 否                                                           |
| 是否需要对表排序   | 否                                                           | 是                                                           |
| 代价估算的重点     | Join的代价                                                   | 表扫描的代价                                                 |
| 统计信息的使用     | 为表的选取与否提供计算依据；<br/>为多表连接和其他操作提供了计算依据。 | 为表的选取与否提供计算依据；<br/>为多表连接和其他操作提供了计算依据。 |
| 优势               | 最优                                                         | 高效且思路简单，算法复杂度低                                 |
| 缺点               | 算法复杂度高，空间需求大，表多时效率降低                     | 局部最优                                                     |

# 贪心启发算法
当需要Join的表数量过多(通常超过10个)适合贪心，其优势在于可以较快第找到还不错的Join Order。其核心思想是，从一张表扩展到N张表，每次选出当前代价最小的一张表，加入Join Tree，构建出Left Deep Tree。贪心算法也有很多扩展，主要扩展点围绕避免局部最优以及产生Bushy Tree。

# 枚举算法
主流的两种
- 基于规则变换的Top-down枚举，可以结合Top-down cascasde 框架通过记忆化的方式来实现。
- 基于DP的bottom-up 枚举，典型代表DPhyp算法，其优势在于可以高效的产生bushy tree

一般情况下，数据库系统会把贪心和枚举有效的结合，从而对任意数量的表join 都能够在合理的时间内得到有效的Join Order。

