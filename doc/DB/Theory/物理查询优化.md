## 查询代价估算

### 代价模型

查询代价估算基于CPU代价和IO代价，所以代价模型可以用以下计算公式表示：
$$
\begin{array}{l}
总代价 = IO 代价 + CPU 代价 \\
COST = P*a\_page\_cpu\_time + W * T \\
\end{array}
$$
其中：

- P为计划运行时访问的页面数
- $a\_page\_cpu\_time$是每个页面读取的时间花费，$P * a\_page\_cpu\_time$反映了IO代价。
- T为访问的元组数，反映了CPU花费（存储层是以页面为单位，数据以页面的形式被读入内存，每个页面上可能有多条元组，访问元组需要解析元组结构，才能把元组上的字段读出，这消耗的是CPU）。如果是索引扫描，则还会包括索引读取的花费。
- W为权重因子，表明IO到CPU的相关性，又称选择率(selectivity)。选择率用于表示在关系R中，满足条件`A<op>a`的元组数与R的所有元组数N的比值。

### 选择率

选择率计算的常用方法有

- 无参数方法（Non-Parametric Method）。使用ad hoc数据结构或直方图维护属性值的分布，最常用的是直方图方法
- 参数法（Parametric Method）。使用具有一些自由统计参数（参数是预先估计出来的）的数学分布函数逼近真实分布。
- 曲线拟合法（Curve Fitting）。为克服参数法的不灵活性，用一般多项式和标准最小方差来逼近属性值的分布。
- 抽样法（sampling）。从数据库中抽取部分样本元组，针对这些样本进行查询，然后收集统计数据，只有足够的样本被测试之后，才能达到预期的精度。
- 综合法。将以上几种方法结合起来，如抽样法和直方图法结合。

## 单表扫描算法

单表扫描需要从表上获取元组，直接关联到物理IO的读取，所以不同的单表扫描方式，有不同的代价。常用的单表扫描方式：

- 全表扫描表数据。为获取表的全部元组，读取表对应的全部数据页，通常采取顺序读取的算法。
- 局部扫描表数据。为获取表的部分元组，读取指定位置对应的数据页。
  

常用的单表扫描算法：

- 顺序扫描（SeqScan）。从物理存储上按照存储顺序直接读取表的数据；当无索引可用，或访问表中的大部分数据，或表的数据量很小时，使用顺序扫描效果较好。
- 索引扫描（IndexScan）。根据索引键读索引，找出物理元组的位置；根据从索引中找到的位置，从存储中读取数据页面；索引扫描可以将元组按排序的顺序返回；索引扫描时若选择率较低，则读数据花费的IO会显著减少；换句话说，如果选择率很高，不适宜使用索引扫描。
- 只读索引扫描（IndexOnlyScan）。根据索引键读索引，索引中的数据能够满足条件判断，不需要读取数据页面；比索引扫描少了读取数据的IO花费。
- 行扫描（RowIdScan）。用于直接定位表中的某一行。对于元组，通常为元组增加特殊的列，可以通过特殊的列计算出元组的物理位置，然后直接读取元组对应的页面，获取元组；在PostgreSQL中称为Tid扫描，此种方式是在元组头上增加名为CTID的列，用这列的值可以直接计算本条元组的物理存储位置。
- 并行表扫描（ParallelTableScan）。对同一个表，并行地、通过顺序的方式获取表数据，结果得到一个完整表数据。
- 并行索引扫描（ParallelIndexScan）。对同一个表，并行地、通过索引的方式获取表的数据，将结果合并在一起。
- 组合多个索引扫描。有的系统称为MultipleIndexScan。对同一个元组的组合条件（AND或者OR谓词组合的多个索引列上的多条件查询）进行多次索引扫描，然后在内存里组织一个位图，用位图描述索引扫描结果中符合索引条件的元组位置。组合多个索引（包括同一索引的多次使用）来处理单个索引扫描不能实现的情况。本质上不是单表的扫描方式，是构建在单表的多个索引扫描基础上的。

对于局部扫描，根据数据量的情况和元组获取条件，可能采用顺序读取或随机读取存储系统的方式。此时，选择率有一定影响。如果选择率的值很大，意味着采取顺序扫描方式可能比局部扫描的随机读的方式效率更高，由于顺序IO会减少磁盘头移动的等待时间，如果数据库文件在磁盘上没有碎片，对性能的改善将更明显。对于大表，顺序扫描会一次读取多个页，这将进一步降低顺序表扫描的开销。
对于局部扫描，通常采用索引，实现少量数据的读取优化，是一种随机读取数据的方式。虽然顺序表扫描可能会比读取许多行的索引扫描花费的时间少，但如果顺序扫描被执行多次，且不能有效地利用缓存，则总体花费巨大。索引扫描访问的页面可能较少，而且这些页很可能会保存在数据缓冲区，访问的速度会更快。所以，对于重复的表访问（如嵌套循环连接的右表），采用索引扫描比较好。究竟采取哪种扫描方式，查询优化器在采用代价估算比较代价的大小后才决定。

### 单表扫描代价计算

$$
\begin{array}{l}
顺序扫描 \\
cost = N\_page * a\_tuple\_IO\_time + N\_tuple * a\_tuple\_CPU\_time \\
\\
索引扫描 \\
cost = C\_index + N\_page\_index * a\_tuple\_IO\_time\\

\end{array}
$$

其中：

- $a\_page\_IO\_time$，一个页面的IO花费。
- $N\_page$，数据页面数。
- $N\_page\_index$，索引页面数。
- $a\_tuple\_CPU\_time$，一个元组从页面中解析的CPU花费。
- $N\_tuple$，元组数。
- $C\_index$，索引的IO花费，$C\_index=N\_page\_index * a\_page\_IO\_time$
- $N\_tuple\_index$，索引作用下的可用元组数,$N\_tuple\_index=N\_tuple * 索引选择率$

# 两表连接算法



# 参考资料

- 数据库查询优化器的艺术:原理分析和SQL性能优化