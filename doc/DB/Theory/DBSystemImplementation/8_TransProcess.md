实现事务管理处理，面临两个问题：

1.  为了提高效率，要允许事务并发执行。
2.  为了保持正确性，要确保并发执行的事务遵守ACID性质。

并发事务机制可能导致多种读写异常。隔离级别描述并限制了这些异常是否可以出现，并发机制决定了事务如何被调度和执行。

页缓存负责减少磁盘访问的次数。当缓存达到容量时，页将被换出并刷写回磁盘。为了确保节点崩溃时不会丢失未落盘的更改，以及支持事务回滚，会记录预写日志。页缓存和预写日志使用force和steal策略进行协调，确保在不失持久性的前提下，每个事务可以高效执行并且能够回滚。

# 缓冲区管理

 # 恢复



# 并发控制

事务管理器和锁管理器协同工作来处理并发控制，并发控制是一组用于处理并发事务间交互的技术，这些技术可以划分为以下几类：

1. 乐观并发控制
2. 多版本并发控制
3. 悲观并发控制



## 可串行化

如果一个调度中的事务完全独立且无交错地执行，则我们称它为串行的调度：每个事务在下一个事务开始之前已完全执行。



可串行化调度可以满足并发执行事务操作，同时保持串行调度的正确性和简单性。<b><font color="green">如果一个调度等效于同一组事务的某一完整串行调度，则该调度是可串行化的。</font></b>换句话说，它产生的结果与我们以某种顺序一个接一个地执行一组事务的结果相同。



## 事务隔离

<b><font color="orange">隔离级别指定了事务的各部分如何以及何时可以被其他事务看到。</font></b>换句话说，隔离级别描述了将事务与其他并发事务隔离的程度以及执行过程中可能发生哪些种类的异常(anomaly)。实现隔离需要付出一定的代价：为了防止其他事务读到不完整或临时的写入，我们需要额外的协调和同步机制，而这会对性能产生负面影响。



SQL标准描述了执行并发事务期间可能发生的读异常：脏读(dirty read)、不可重复度(nonrepeatable  read)和幻读()。

| 读异常     | 概念                                                         | 示例描述                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 脏读       | 一个事务能读到其他事务未提交的更改                           | 事务T1更新了一条用户记录的地址字段，事务T2在T1提交前就读到了已被更新的地址<br/> |
| 不可重复读 | 也称为模糊度(fuzzy read)，同一事务两次查询同一行却得到不同的结果。 | 事务T1读取一行，然后事务T2修改该行并提交了这一更改。如果T1在完成执行之前再次查询同一行，则结果将会和前一次查询不同。 |
| 幻读       | 事务两次查询同样的行集合却得到不同的结果。它与不可重复读类似，但仅适用于范围查询。 |                                                              |

也存在具有类似语义的写异常：丢失更新(Lost Update)，脏写和写偏斜。

| 写异常   |                                                              | 示例描述                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 丢失更新 | 发生在事务T1和T2同时尝试更新V的值时。T1和T2读取V的值。T1更新V并提交，之后T2也更新V并提交。由于这两个事务不知道彼此的存在，所以如果允许二者都提交，则T1的结果将被T2的结果覆盖，T1的更新。 |                                                              |
| 脏写     | 某个事务拿到了一个未提交的值（即脏读），对其进行修改并保存，也就是说，事务结果来自从未提交过的值。 |                                                              |
| 写偏斜   | 各个单独的事务都遵守要求的约束，但它们的组合却违反了这些约束。 | 事务T1和T2修改两个账户A1和A2的值。最初A1有100元，A2有150元。<br/><br/>账户的值可以为负，只要两个账户之和为非负数就行，即要满足A1+A2≥0。<br/><br/>T1和T2分别尝试分别从A1和A2取出200元。在两个事务开始时，A1+A2=250元，因此共有250元可用。两个事务都认为它们没有违反约束，可以提交。提交后，A1为-100元，A2为-50元，这显然违反了账户之和为非负数的要求 |



<b><font color="orange">隔离级别和允许的异常</font></b>

|          隔离级别          |  脏读  | 不可重复读 |  幻读  |
| :------------------------: | :----: | :--------: | :----: |
| 读未提交(read uncommitted) |  允许  |    允许    |  允许  |
|  读已提交(read commited)   | 不允许 |    允许    |  允许  |
| 可重复读(repeatable read)  | 不允许 |   不允许   |  允许  |
| 可串行化(serializability)  | 不允许 |   不允许   | 不允许 |

ACID中的隔离性意味着可串行化。实现可串行化需要协调，也就是说，并发执行的事务必须进行协调以确保遵守约束，并在发生冲突时强加某一串行顺序。

一些DB采用快照隔离，在快照隔离(snapshot isolation)中，一个事务可以观察到所有在该事务开始前已提交的事务所做的状态更改。每个事务都会获取一个数据快照，并在快照上执行查询。快照在事务执行期间不会发生变化。只有当事务中修改的值没有被其他事务修改时，才可以提交事务，否则它将被中止并回滚。

- 如果两个事务试图修改同一个值，则只有其中一个事务能够提交，这会防止丢失更新异常。例如，事务T1和T2都尝试修改V。它们从快照读取V的当前值。首先尝试提交的事务会成功提交，而另一个事务则必须中止。失败的事务将会重试，而不是覆盖已修改的值。
- 快照隔离中可能发生写偏斜异常：如果两个事务分别读取本地状态、修改不同的记录并且遵守本地的约束。