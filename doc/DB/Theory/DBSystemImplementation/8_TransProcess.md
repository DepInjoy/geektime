通常将一个或多个数据库操作组成一组，称作事务，事务必须作为一个原子，外观上独立于其他事务执行的单位，且DBMS保证持久性，即已完成事务所做的工作不会丢失。数据库系统事务遵从的ACID：

- 原子性(Atomicity)：事务的步骤是不可分的，这意味着，事务中的所有步骤要么全都执行成功，要么全都不执行。
- 一致性(Consistency)：一致性是一种特定于具体应用的保证：事务只能将数据库从一个有效状态带到另一个有效状态，并保持所有的数据库不变量(比如约束、引用完整性等)，一致性是定义最弱的属性。
- 隔离性(Isolation)：多个并发执行的事务应该能够互不干扰地运行，每个事务都像没有其他事务一样同时执行。隔离性定义了何时以及哪些对数据库状态的更改可以对并发事务可见。出于性能原因，许多数据库使用的隔离级别要弱于这里给出的隔离性定义。
- 持久性(Durability)：一旦事务被提交，所有数据库状态的修改都必须被持久化到磁盘上，即使之后发生断电、系统故障或崩溃也不受影响。

事务处理器分成两个主要部分：

- **并发控制管理器或调度器**，负责保证事务的原子性(Atomicity)和隔离性(Isolation)。
- **日志和恢复管理器**，负责事务的持久性(Durability)。

# 组件和职责

事务管理器从应用系统接受事务命令，从而得知什么时候事务开始，什么时候事务结束。事务处理器执行下面的任务：

1. **日志记录**。为了保证持久性，对于数据库的每一个变化都在磁盘上记录日志。**日志管理器**遵循某几种策略中的某一种工作，这些策略保证任何时候系统发生故障或崩溃，**恢复管理器**都可以查看关于数据库变化的日志，并将数据库恢复到某个一致的状态。开始时，日志管理器将日志写到缓冲器，它与缓冲区管理器协调，保证在适当的时候将缓冲区写到磁盘。
2. **并发控制**。调度器(并发控制管理器)保证多个事务的一个个动作以一种适当的顺序执行，从而是的最终的结果与这些事务事实上一个执行完再执行下一个动作结果相同。典型的调度器通过在数据库的某些部分上维护若干个锁来工作。这些锁防止两个事务造成不良后果的方式存取数据库的相同部分。锁通常存储在主存储器的**锁表**中，调度器禁止执行引擎访问数据库中被封锁的部分，从而对查询和其他数据库操作的执行产生产生影响。
3. **死锁解决**。事务之间通过调度器所授予的锁进行资源竞争时，可能会进入这样的情况：没有任何一个事务可以进行下去，因为任何一个事务都需要另一个事务所持有的某个资源。事务管理器有责任进行干预，取消(回滚)一个或多个事务，从而让其他的事务可以进行下去。

数据库系统实现事务需要多个组件协同工作：

- 事务管理器负责协调、调度和跟踪事务及事务的各个步骤。
- 锁管理器保护对资源的访问，并防止那些可能破坏数据完整性的并发访问。
- 页缓存充当持久性存储(磁盘)和存储引擎其余部分之间的中介。它将状态更改暂存在内存中，同时也用于缓存那些尚未与持久性存储同步的页。
- 日志管理器记录了已应用在缓存页上的操作（日志条目），这些操作尚未与持久性存储同步，而日志可以确保这些操作不会在崩溃时丢失。
- 分布式（多分区）事务需要额外的协调机制以及远程执行。

# 缓冲区管理

大多数数据库都采用双层存储体系：较慢的持久性存储（磁盘）和较快的主内存（RAM）。为了减少对持久性存储的访问次数，页面被缓存在内存中。当存储层再次请求该页时，将返回其缓存副本。
假设没有其他进程修改磁盘上的数据，则内存中的缓存页可以被重用，也称为虚拟磁盘。仅当内存中没有页副本可用时，对虚拟磁盘的读取才会访问物理存储，这种机制称为为**页缓存或缓冲池**。

- 将未缓存的页从磁盘加载进来的过程称为**换入(page in)**。当存储引擎请求页时，首先检查其内容是否已被缓存。如果该页在缓存中，则直接返回缓存的页。如果该页未被缓存，则页缓存会将其逻辑地址或页号转换为物理地址，并将它的内容加载到内存，然后返回已缓存的版本给存储引擎。一旦返回，这个存有缓存页内容的缓冲区就称为被引用的(referenced)，存储引擎必须在用完之后将其归还给页缓存或解除引用。若想让页缓存不要换出某些页，则可以将它们固定(pin)。
- 缓存的页一旦被更改过就成了**脏页**，直到这些更改被刷写(flush)到磁盘上。页上的脏标志位表示其内容与磁盘不同步，必须将其刷写到磁盘上才能保证持久性。
- 由于页缓存的内存区通常比整个数据集小得多，所以页缓存终究会被填满。为了换入新页，必须将其中某个页**换出(evict)**缓存。



## 缓存回收

保持缓存填满的状态是件好事：让更多的读请求无须经过持久性存储，也让同一页上更多的修改能被缓冲在一起。但页缓存的容量毕竟是有限的，迟早会用尽所有空间，彼时为了放下新内容只能换出旧页。如果页的内容与磁盘是同步的，并且该页面未被固定或引用，则可以立即将其换出。脏页则必须在刷写之后才能换出。如果页正在被其他线程使用，则不能将其换出。

如果每次换出页都刷写磁盘，则其性能可能会很差。因此某些数据库使用单独的后台进程，该进程循环检查可能被换出的脏页，更新其磁盘上的版本。例如，PostgreSQL中的一个后台刷写器就是用来做这件事情的。

事务的另一个属性是持久性：如果数据库崩溃，则所有未刷写的数据都会丢失。为了确保所有更改都被持久化，检查点进程会协调刷写进程。检查点进程控制预写日志（WAL）和页缓存，并确保两者协同工作。只有当缓存页完成刷写之后，相关操作的日志记录才能从WAL中丢弃。在上述过程完成后才能将脏页换出缓存。这意味着需要在多个目标间做一些权衡：

- 推迟刷写以减少磁盘访问次数。
- 提早刷写以让页能被快速地换出。
- 选择要换出的页，并以最优的顺序刷写。
-  将缓存大小保持在其内存范围内。
-  避免因数据没有被持久化到主存储中而丢失它们。

下面的几种技术可以帮助改善前三个特性，同时保持在另外两个特性的范围之内。



## 在缓存中锁定页

由于B树越靠近顶部越“窄”，所以靠近根的节点大多数读取中都会被命中。分裂与合并操作最终也会传播到较高层次的节点。这意味着至少树的某一部分一定会受益于缓存。

<b><font color=orange>“锁定“那些在近期大概率会被用到的页。在缓存中锁定页的操作称为固定。被固定的页会在内存中保留更长的时间，这有助于减少磁盘访问次数并提高性能。</font></b>

在B树上，随着节点层次的降低，每层的节点数量呈指数级增加，并且较高层次的节点仅占整棵树的一小部分，因此这部分节点可以永久驻留在内存中，而其他部分则可以按需换入。这意味着，在执行一次查询时不必进行h次磁盘访问(h表示树的高度)，只有在访问那些未被缓存的低层页时才会真正读取磁盘。

针对子树执行的操作可能会导致相互矛盾的结构变化，例如：多次删除操作导致节点合并，随后写入又导致分裂，或者相反。从不同子树传播上来的结构变化亦是如此（结构变化的发生时间很接近，但是发生在树的不同部分，并向上传播）。通过仅在内存中应用更改，可以将这些操作缓冲在一起，从而减少磁盘写入的次数并分摊写入成本，因为只要做一次磁盘写入即可，无须写入多次。



## 预取和立即换出

页缓存也允许存储引擎对预取和换出进行细粒度的控制，存储引擎可以指示页缓存在访问页之前提前加载页。例如，当在范围扫描中遍历叶节点时，可以预加载下一个叶节点。同样，如果后台维护进程加载了某个页，则可以在进程完成后立即将其换出缓存，因为它不太可能被进行中的查询用到。某些数据库（例如PostgreSQL）使用循环缓冲区（即先进先出的页置换策略）进行大规模顺序扫描。



## 页置换

当缓存容量用完时，为了加载新页，必须换出旧页。为了实现高效的也缓存，需要找出一种有效的页置换算法。

使用更大的缓存能够帮助我们减少换出的次数，听起来似乎很合理。但事实并非如此。可以说明这种困境的例子之一是$B\acute{e}l\acute{a}dy$异常(布雷迪异常)。它表明，如果使用的页置换算法不是最优的，则增加页数可能导致换出的次数增加。当很快可能会用到的页被换出缓存然后又被再次加载时，页将开始争夺缓存中的空间。因此，需要考虑使用算法来改善情况。



### FIFO和LRU

最简单的页置换策略是先进先出（FIFO）。FIFO按插入顺序维护一个页ID的队列，将新页添加到队列尾部。每当页缓存已满时，FIFO从队列头部取出元素，这也就是最早被换入的页。由于它不考虑后续的页访问，而是仅考虑页换入时间，所以该策略对于大多数真实系统而言是不切实际的。例如，根节点和最上层节点的页最先被换入，根据此算法，这些页也会被最先换出缓存，尽管从树结构中能明显看出这些页很快就会被再次换入。

对FIFO算法的自然扩展是最长时间未使用策略(LRU)，LRU也按插入顺序维护一个换出候选队列，但是当重复访问某个页时，LRU会将其放回队列尾部，就像首次换入时那样。然而，并发环境下每次访问都要更新引用和重新链接节点可能代价较高。

此外还有一些基于LRU的缓存换出策略。例如，

- `2Q`（双队列LRU）维护两个队列，在初次访问时放入第一个队列，在后续访问时将它们移入第二个热队列，从而区分最近访问的页和经常访问的页。

- `LRU-K`通过跟踪最近的K次访问来识别频繁用到的页，并使用此信息来估计访问时间



### Clock算法

在某些情况下，效率可能比精度更重要。CLOCK算法变体常常被用作LRU的一种更加紧凑、更加缓存友好且并发性更好的替代品。

CLOCK-sweep算法将页的引用和与之关联的访问位保存在环形缓冲区中。一些变体使用计数器而不是比特位来描述频率。每当访问某个页面时，都将它的访问位设置为1。CLOCK算法的工作原理是循环检查环形缓冲区上的访问位：

- 如果访问位为1且该页未被引用，则将其置为0并检查下一页。
- 如果访问位已经为0，则将该页作为一个要换出的候选，并安排在后续将其换出。
-  如果页当前正被引用，则它的访问位保持不变。算法假定被访问页的访问位不可为0，因此不会被换出缓存，这使得被引用的页更不可能被置换。

使用环状缓冲区的一个优点是：时钟指针和缓冲区内容都可以用比较-置换（CAS）原子操作来修改，无须额外的加锁机制。该算法很容易理解和实现。



### LFU

追踪页引用事件而不是页换入事件，其中一种实现是跟踪具有最小使用频率（LFU）的页。TinyLFU是一种基于频率的页置换策略：TinyLFU不根据页换入的时间来换出页，而是根据使用频率对页进行排序，被用于一个流行的Java库Caffeine中。
TinyLFU使用频率直方图来维护一个紧凑的缓存访问历史记录。元素可能位于以下三个队列中的某一个：

- 入场（admission）队列：维护新加入的元素，用LRU策略实现。
-  考察（probation）队列：其中的元素最有可能被换出缓存。
-  保护（protected）队列：其中的元素将在队列中保留更长的时间。

TinyLFU不是选择要换出哪些元素，而是选择要保留的元素。访问频率相对较高的元素会被晋升到考察队列中。在后续访问中，元素可以从考察队列移至保护队列。如果保护队列已满，则必须将其中某个元素放回考察队列。经常访问的元素有较高的机会被保留，而不经常访问的元素则更有可能被换出缓存。

<center>
  <img src="./img/BufferCache_TinyLFU.png">
</center>



# 恢复管理



# 并发控制

事务管理器和锁管理器协同工作以处理并发控制。并发控制是一组用于处理并发事务间交互的技术，可以分为以下几类：

- 乐观并发控制(OCC)：允许多个事务执行并发的读取和写入操作，最后确定其执行结果能否被串行化。换句话说，事务不会彼此阻塞，而是保留其操作历史，并在提交前检查这些历史操作是否存在冲突的可能。如果会产生冲突，则中止其中某一个冲突的事务。

- 多版本并发控制(MVCC)：允许一条记录同时存在多个时间戳的版本，通过这种方式保证事务读到的是数据库过去某个时刻的一致视图。MVCC可以使用验证技术来实现，即只允许多个更新或事务提交中的某一个获胜，也可以使用无锁技术(例如时间戳排序)或基于锁的技术(例如两阶段锁)

- 悲观(也称保守)并发控制(PCC)：既有基于锁的实现，也有不加锁的实现，它们的主要区别在于如何管理和授权对共享资源的访问。悲观的调度可能导致死锁：多个事务需要互相等待对方释放锁才能继续执行。
    - 基于锁的实现要求事务维护数据库记录上的锁，以防止其他事务修改被加锁的记录或访问当前事务正在修改的记录，直到锁被释放为止。
    - 不加锁的实现根据未完成事务的调度，维护读取与写入的操作列表以限制事务的执行。



## 可串行化

事务包括对数据库状态的一系列读取和写入操作以及业务逻辑(应用于读取内容上的转换)。**调度(schedule)**是指数据库视角上执行一组事务所需的操作列表(即仅包含与数据库状态交互的操作，例如读、写、提交和中止)。

如果一个调度中包含其中每个事务的所有操作，则称它是**完整**的。一个正确的调度在逻辑上等效于原始操作列表，但是可以并行执行其中某些部分，也可以出于优化目的对其进行重新排列，只要不违反ACID性质并保证各事务的结果正确即可

如果一个调度中的事务完全独立且无交错地执行，则称它为串行的调度：每个事务在下一个事务开始之前已完全执行。可串行化调度可以满足并发执行事务操作，同时保持串行调度的正确性和简单性。<b><font color="orange">如果一个调度等效于同一组事务的某一完整串行调度，则该调度是可串行化的。</font></b>换句话说，它产生的结果与我们以某种顺序一个接一个地执行一组事务的结果相同。

<center>
  <img src="./img/Trans_Execute_seq.png">
    <div>一组并发事务及其可能的执行顺序</div>
</center>




## 事务隔离

<b><font color="orange">隔离级别指定了事务的各部分如何以及何时可以被其他事务看到。</font></b>换句话说，隔离级别描述了将事务与其他并发事务隔离的程度以及执行过程中可能发生哪些种类的异常(anomaly)。实现隔离需要付出一定的代价：为了防止其他事务读到不完整或临时的写入，我们需要额外的协调和同步机制，而这会对性能产生负面影响。



SQL标准描述了执行并发事务期间可能发生的读异常：脏读(dirty read)、不可重复度(nonrepeatable  read，也称为模糊读fuzzy read)和幻读。

| 读异常     | 概念                                                         | 示例描述                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 脏读       | 一个事务能读到其他事务未提交的更改                           | 事务T1更新了一条用户记录的地址字段<br/>事务T2在T1提交前就读到了已被更新的地址 |
| 不可重复读 | 也称为模糊度(fuzzy read)，同一事务两次查询同一行却得到不同的结果。 | 事务T1读取一行，然后事务T2修改该行并提交了这一更改。如果T1在完成执行之前再次查询同一行，则结果将会和前一次查询不同。 |
| 幻读       | 事务两次查询同样的行集合却得到不同的结果。它与不可重复读类似，但仅适用于范围查询。 |                                                              |

也存在具有类似语义的写异常：丢失更新(Lost Update)，脏写和写偏斜。

| 写异常   |                                                              | 示例描述                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 丢失更新 | 发生在事务T1和T2同时尝试更新V的值时。T1和T2读取V的值。T1更新V并提交，之后T2也更新V并提交。由于这两个事务不知道彼此的存在，所以如果允许二者都提交，则T1的结果将被T2的结果覆盖，T1的更新。 |                                                              |
| 脏写     | 某个事务拿到了一个未提交的值（即脏读），对其进行修改并保存，也就是说，事务结果来自从未提交过的值。 |                                                              |
| 写偏斜   | 各个单独的事务都遵守要求的约束，但它们的组合却违反了这些约束。 | 事务T1和T2修改两个账户A1和A2的值。最初A1有100元，A2有150元。<br/><br/>账户的值可以为负，只要两个账户之和为非负数就行，即要满足A1+A2≥0。<br/><br/>T1和T2分别尝试分别从A1和A2取出200元。在两个事务开始时，A1+A2=250元，因此共有250元可用。两个事务都认为它们没有违反约束，可以提交。提交后，A1为-100元，A2为-50元，这显然违反了账户之和为非负数的要求 |



<b>隔离级别和允许的异常</b>

|          隔离级别          |  脏读  | 不可重复读 |  幻读  |
| :------------------------: | :----: | :--------: | :----: |
| 读未提交(read uncommitted) |  允许  |    允许    |  允许  |
|  读已提交(read commited)   | 不允许 |    允许    |  允许  |
| 可重复读(repeatable read)  | 不允许 |   不允许   |  允许  |
| 可串行化(serializability)  | 不允许 |   不允许   | 不允许 |

ACID中的隔离性意味着可串行化。实现可串行化需要协调，也就是说，并发执行的事务必须进行协调以确保遵守约束，并在发生冲突时强加某一串行顺序。

一些DB采用快照隔离，在快照隔离(snapshot isolation)中，一个事务可以观察到所有在该事务开始前已提交的事务所做的状态更改。每个事务都会获取一个数据快照，并在快照上执行查询。快照在事务执行期间不会发生变化。只有当事务中修改的值没有被其他事务修改时，才可以提交事务，否则它将被中止并回滚。

- 如果两个事务试图修改同一个值，则只有其中一个事务能够提交，这会防止丢失更新异常。例如，事务T1和T2都尝试修改V。它们从快照读取V的当前值。首先尝试提交的事务会成功提交，而另一个事务则必须中止。失败的事务将会重试，而不是覆盖已修改的值。
- 快照隔离中可能发生写偏斜异常：如果两个事务分别读取本地状态、修改不同的记录并且遵守本地的约束。

# 参考资料

1. 《数据库系统实现 第二版》
2. 《数据库系统内幕》