# 代数和逻辑查询语言
## 包上关系操作

并的交换律:
$$
R \cup S = S \cup R
$$
集合并的分配律且需要R和S都是集合，不适用于包
$$
(R \cup S)-T = (R -T) \cup (S - T)
$$

$$

$$


## 关系代数的扩展操作符

## 关系逻辑

逻辑查询语言Datalog(database logic)由if-then规则组成，这些规则表示：从某个关系的特定元组的组合可以推断出另外一些元组必定满足另一关系，或满足查询结果。



**谓词和关系**

关系在Datalog中由谓词(predicate)表示，。每个谓词拥有固定数目的参数，一个谓词和它的参数一起被称为原子(atom)，为了和算术原子区分，也称为关系原子(relation atom)。原子的语法像变成语言中函数调用语法。例如$P(x_1, x_2,....x_n)$即是一个由谓词P和参数$x_1, x_2,..., x_n$组成的原子。实质上谓词局势一个返回布尔值的函数名。如果R是一个包含n个固定顺序的属性关系，那么可以用R作为对应这个关系的谓词名。如果$(a_1, a_2,...,a_n)$是满足R的元组，那么元组$R(a_1,a_2, ...,a_n)$的值为True，否则元组的值为False。<font color=red><b>需要注意，谓词定义的关系都是集合关系，之后再讨论将Datalog扩展到包</b></font>



**算术原子(arithmetic atom)**

算术原子时对两个算术表达式作比较，例如 x< y或$x+1 \gt y+4 \times z$



**Datalog规则和查询**

和关系代数类似的操作在Datalog中称作规则(rule)，它包括：

1. 一个称为头部(head)的关系原子
2. 符号$\longleftarrow$, 经常读作if
3. 主体(body)部分，由一个或多个称为子目标(subgoal)的原子组成。原子可以是关系原子或算术元组。子目标之间由AND连接，任何目标之前都可以随意添加逻辑算子NOT。

Datalog中规则适用变量是有限制的，该限制是要使得一条规则的结果是一个有限的关系，从而包含算术子目标或否定(negated)子目标的规则更有直观意义，这个限制条件称作**安全(safety)条件**，含义是:

- 每个在规则中任意位置出现的变量都必须出现在主体的某些非否定的关系子目标中。

尤其是，任何在规则头部，否定关系子目标或任意算术子目标中出现的变量，也必须出现在主体的非否定的关系子目标中。



Datalog规则的意义：假设规则变量涉及所有可能的值，只要这些变量的值使得所有子目标为真，那么对应于这些变量的规则头部的值就清楚了，并可把结果元组加入到头部谓词关系中。另外一种定义规则的意义：不去考虑所有可能的变量赋值，而是考虑对应于每个非否定关系子目标的关系的元组集合。如果每个非否定关系子目标的某些元组的赋值是一致(consistent)的，也就是说，对一个变量的每次出现都赋同一个值，则考虑对规则所有变量的结果赋值。因为规则是安全的，所以每个变量都被赋了一个值。

## 关系代数与Datalog

## 