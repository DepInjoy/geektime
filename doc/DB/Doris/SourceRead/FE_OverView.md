MysqlServer `Listener()`负责监听客户端发送来的 Mysql 连接请求，每个连接请求都被封装成一个 `ConnectContext`对象，并被提交给 ConnectScheduler。ConnectScheduler 会维护一个线程池，每个`ConnectContext`会在线程池中由一个 `ConnectProcessor`线程处理。

`ConnectProcessor`中的`processOnce()`实现

```java
    // Process a MySQL request
    public void processOnce() throws IOException {
        // set status of query to OK.
        ctx.getState().reset();
        executor = null;

        // reset sequence id of MySQL protocol
        final MysqlChannel channel = ctx.getMysqlChannel();
        channel.setSequenceId(0);
        // read packet from channel
        packetBuf = channel.fetchOnePacket();

        // dispatch,会话会将查询会将DML, DCL/DDL语句分发给不同模块处理
        dispatch();
        // finalize
        finalizeCommand();

        ctx.setCommand(MysqlCommand.COM_SLEEP);
    }

    private void dispatch() throws IOException {
        int code = packetBuf.get();
        MysqlCommand command = MysqlCommand.fromCode(code);
        LOG.debug("handle command {}", command);
        ctx.setCommand(command);
        ctx.setStartTime();

        switch (command) {
			.....
            // SQL查询和prepare语句
            case COM_QUERY:
            case COM_STMT_PREPARE:
                ctx.initTracer("trace");
                Span rootSpan = ctx.getTracer().spanBuilder("handleQuery")
                    .setNoParent().startSpan();
                // 忽略异常处理简化代码
                // 重点!!! handleQuery实现对查询的处理
                handleQuery(command);
                rootSpan.end();
                break;
			......
        }
    }
```



```java
    private void handleQuery(MysqlCommand mysqlCommand) {
				......
        // convert statement to Java string
        byte[] bytes = packetBuf.array();
        int ending = packetBuf.limit() - 1;
        while (ending >= 1 && bytes[ending] == '\0') ending--;
        String originStmt = new String(bytes, 1, ending, StandardCharsets.UTF_8);

        		.....
        List<StatementBase> stmts = null;

        // ！！！ Doris 2.0 Nereids处理入口
        // 目前Nereids不支持prepare和execute,这里只处理query commad
        if (mysqlCommand == MysqlCommand.COM_QUERY &&	
            		ctx.getSessionVariable().isEnableNereidsPlanner()) {
            stmts = new NereidsParser().parseSQL(originStmt);
        }

        // stmts == null when Nereids cannot planner this query or Nereids is disabled.
        if (stmts == null) {
            stmts = parse(originStmt);
        }

        List<String> origSingleStmtList = null;
        // if stmts.size() > 1, split originStmt to multi singleStmts
        if (stmts.size() > 1) {
			origSingleStmtList = SqlUtils.splitMultiStmts(originStmt);
        }

        boolean usingOrigSingleStmt = origSingleStmtList != null &&
            	origSingleStmtList.size() == stmts.size();
        for (int i = 0; i < stmts.size(); ++i) {
            String auditStmt = usingOrigSingleStmt ? origSingleStmtList.get(i) : originStmt;

            ctx.getState().reset();
            if (i > 0) ctx.resetReturnRows();

            StatementBase parsedStmt = stmts.get(i);
            parsedStmt.setOrigStmt(new OriginStatement(originStmt, i));
            parsedStmt.setUserInfo(ctx.getCurrentUserIdentity());
            executor = new StmtExecutor(ctx, parsedStmt);
            ctx.setExecutor(executor);

            // 这里会调用executeByNereids
            // 或executeByLegacy(进行analyze)
            executor.execute();
            if (i != stmts.size() - 1) {
                ctx.getState().serverStatus |= MysqlServerStatusFlag.SERVER_MORE_RESULTS_EXISTS;
                if (ctx.getState().getStateType() != MysqlStateType.ERR) {
                    finalizeCommand();
                }
            }
            auditAfterExec(auditStmt, executor.getParsedStmt(), 
                           executor.getQueryStatisticsForAuditLog(), true);
            // execute failed, skip remaining stmts
            if (ctx.getState().getStateType() == MysqlStateType.ERR) {
                break;
            }
        }
    }
```



```java
// analyze the origin stmt and return multi-statements
private List<StatementBase> parse(String originStmt) throws AnalysisException, DdlException {
    // Parse statement with parser generated by CUP&FLEX
    SqlScanner input = new SqlScanner(new StringReader(originStmt),
                                      ctx.getSessionVariable().getSqlMode());
    SqlParser parser = new SqlParser(input);
    return SqlParserUtils.getMultiStmts(parser);
}

public static List<StatementBase> getMultiStmts(SqlParser parser) throws Exception {
    List<StatementBase> stmts = (List<StatementBase>) parser.parse().value;
    while (stmts.size() > 1 && stmts.get(stmts.size() - 1) instanceof EmptyStmt) {
        stmts.remove(stmts.size() - 1);
    }
    return stmts;
}
```



```java
    public void execute() throws Exception {
        UUID uuid = UUID.randomUUID();
        TUniqueId queryId = new TUniqueId(uuid.getMostSignificantBits(),
                                          uuid.getLeastSignificantBits());
        execute(queryId);
    }

    public void execute(TUniqueId queryId) throws Exception {
        SessionVariable sessionVariable = context.getSessionVariable();
        Span executeSpan = context.getTracer().spanBuilder("execute")
            .setParent(Context.current()).startSpan();
        try (Scope scope = executeSpan.makeCurrent()) {
            if (parsedStmt instanceof LogicalPlanAdapter
                    || (parsedStmt == null && sessionVariable.isEnableNereidsPlanner())) {
                try {
                    // Dois 2.0 Nereids Execute
                    executeByNereids(queryId);
                } catch (NereidsException | ParseException e) {
                    parsedStmt = null;
                    context.getState().setNereids(false);
                    executeByLegacy(queryId);
                }
            } else {
                executeByLegacy(queryId);
            }
        } finally {
            executeSpan.end();
            // revert Session Value, 忽略
        }
    }
```

# analyze

```java
    private void executeByNereids(TUniqueId queryId) throws Exception {
        LOG.debug("Nereids start to execute query:\n {}", originStmt.originStmt);
        context.setQueryId(queryId);
        context.setStartTime();
        context.setStmtId(STMT_ID_GENERATOR.incrementAndGet());

        parseByNereids();
        Preconditions.checkState(parsedStmt instanceof LogicalPlanAdapter,
                "Nereids only process LogicalPlanAdapter, but parsedStmt is " +
                 parsedStmt.getClass().getName());
        context.getState().setNereids(true);
        LogicalPlan logicalPlan = ((LogicalPlanAdapter) parsedStmt).getLogicalPlan();
        if (logicalPlan instanceof Command) {
            if (logicalPlan instanceof Forward) {
                redirectStatus = ((Forward) logicalPlan).toRedirectStatus();
                if (isForwardToMaster()) {
                    forwardToMaster();
                    if (masterOpExecutor != null && masterOpExecutor.getQueryId() != null) {
                        context.setQueryId(masterOpExecutor.getQueryId());
                    }
                    return;
                }
            }
            
            // 忽略异常
            ((Command) logicalPlan).run(context, this);
        } else {
            context.getState().setIsQuery(true);
            if (context.getSessionVariable().enableProfile) {
                ConnectContext.get().setStatsErrorEstimator(new StatsErrorEstimator());
            }
            // create plan
            planner = new NereidsPlanner(statementContext);
            planner.plan(parsedStmt, context.getSessionVariable().toThrift());
            checkBlockRules();
            handleQueryWithRetry(queryId);
        }
    }
```



```java
public void executeByLegacy(TUniqueId queryId) throws Exception {
    context.setStartTime();

    profile.getSummaryProfile().setQueryBeginTime();
    context.setStmtId(STMT_ID_GENERATOR.incrementAndGet());
    context.setQueryId(queryId);
    // set isQuery first otherwise this state will be lost if some error occurs
    if (parsedStmt instanceof QueryStmt) {
        context.getState().setIsQuery(true);
    }

    // support select hint e.g. select /*+ SET_VAR(query_timeout=1) */ sleep(3);
    analyzeVariablesInStmt();

    if (!context.isTxnModel()) {
        Span queryAnalysisSpan = context.getTracer()
            .spanBuilder("query analysis").setParent(Context.current()).startSpan();

        // analyze this query
        analyze(context.getSessionVariable().toThrift());
        queryAnalysisSpan.end();

        if (isForwardToMaster()) {
            forwardToMaster();
		   	.......
        }
    } else {
        analyzer = new Analyzer(context.getEnv(), context);
        parsedStmt.analyze(analyzer);
    }

    if (prepareStmt instanceof PrepareStmt && !isExecuteStmt) {
        handlePrepareStmt();
        return;
    }

    // sql/sqlHash block
    checkBlockRules();
    if (parsedStmt instanceof QueryStmt) {
        handleQueryWithRetry(queryId);
    } else if (parsedStmt instanceof SetStmt) {
        handleSetStmt();
    } else if (parsedStmt instanceof SwitchStmt) {
        handleSwitchStmt();
    } else if (parsedStmt instanceof UseStmt) {
        handleUseStmt();
    } else if (parsedStmt instanceof TransactionStmt) {
        handleTransactionStmt();
    } else if (parsedStmt instanceof CreateTableAsSelectStmt) {
        handleCtasStmt();
    } else if (parsedStmt instanceof InsertOverwriteTableStmt) {
        handleIotStmt();
    } else if (parsedStmt instanceof InsertStmt) {
        // Must ahead of DdlStmt because InsertStmt is its subclass
        InsertStmt insertStmt = (InsertStmt) parsedStmt;
        if (insertStmt.needLoadManager()) {
            handleExternalInsertStmt();
        } else {
            handleInsertStmt();
        }
    } else if (parsedStmt instanceof LoadStmt) {
        handleLoadStmt();
    } else if (parsedStmt instanceof UpdateStmt) {
        handleUpdateStmt();
    } else if (parsedStmt instanceof DdlStmt) {
        if (parsedStmt instanceof DeleteStmt && ((DeleteStmt) parsedStmt).getInsertStmt() != null) {
            handleDeleteStmt();
        } else {
            handleDdlStmt();
        }
    } else if (parsedStmt instanceof ShowStmt) {
        handleShow();
    } else if (parsedStmt instanceof KillStmt) {
        handleKill();
    } else if (parsedStmt instanceof ExportStmt) {
        handleExportStmt();
    } else if (parsedStmt instanceof UnlockTablesStmt) {
        handleUnlockTablesStmt();
    } else if (parsedStmt instanceof LockTablesStmt) {
        handleLockTablesStmt();
    } else if (parsedStmt instanceof UnsupportedStmt) {
        handleUnsupportedStmt();
    } else if (parsedStmt instanceof AnalyzeStmt) {
        handleAnalyzeStmt();
    }
}
```

# rewrite

```C++
// fe/fe-core/src/main/java/org/apache/doris/qe/StmtExecutor.java
private void analyzeAndGenerateQueryPlan(TQueryOptions tQueryOptions) throws UserException {
    
}
```



# SingleNodePlan

```java
public class OriginalPlanner extends Planner;
public void plan(StatementBase queryStmt, TQueryOptions queryOptions)
        throws UserException {
    createPlanFragments(queryStmt, analyzer, queryOptions);
}

public void createPlanFragments(StatementBase statement,Analyzer analyzer,
                                TQueryOptions queryOptions) throws UserException {
    QueryStmt queryStmt;
    if (statement instanceof InsertStmt) {
        queryStmt = ((InsertStmt) statement).getQueryStmt();
    } else {
        queryStmt = (QueryStmt) statement;
    }
    plannerContext = new PlannerContext(analyzer, queryStmt, queryOptions, statement);
    singleNodePlanner = new SingleNodePlanner(plannerContext);
    PlanNode singleNodePlan = singleNodePlanner.createSingleNodePlan();
    if (ConnectContext.get().getExecutor() != null) {
        ConnectContext.get().getExecutor().getSummaryProfile().setCreateSingleNodeFinishTime();
    }
    ProjectPlanner projectPlanner = new ProjectPlanner(analyzer);
    projectPlanner.projectSingleNodePlan(queryStmt.getResultExprs(), singleNodePlan);
    if (statement instanceof InsertStmt) {
        InsertStmt insertStmt = (InsertStmt) statement;
        insertStmt.prepareExpressions();
    }
```



# 参考资料

1. [浅谈 Apache Doris FE 处理查询 SQL 源码解析](https://developer.aliyun.com/article/1124038)