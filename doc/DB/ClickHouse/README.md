ClickHouse为什么那么快？

1. 算法在前，抽象在后

    > 在ClickHouse的底层实现中，经常会面对一些重复的场景，例如字符串子串查询、数组排序、使用HashTable等。如何才能实现性能的最大化呢？算法的选择是重中之重。以字符串为例，有一本专门讲解字符串搜索的书，名为“Handbook of Exact String Matching Algorithms”，列举了35种常见的字符串搜索算法。各位猜一猜ClickHouse使用了其中的哪一种？答案是一种都没有。这是为什么呢？因为性能不够快。在字符串搜索方面，针对不同的场景，ClickHouse最终选择了这些算法：
    >
    > - 对于常量，使用Volnitsky算法
    > - 对于非常量，使用CPU的向量化执行SIMD，暴力优化
    > - 正则匹配使用re2和hyperscan算法。
    >
    > 性能是算法选择的首要考量指标。

2. 　特定场景，特殊优化

    > 例如去重计数uniqCombined函数，会根据数据量的不同选择不同的算法：
    >
    > - 当数据量较小的时候，会选择Array保存
    > - 当数据量中等的时候，会选择HashSet
    > - 当数据量很大的时候，则使用HyperLogLog算法。
    >
    > 对于数据结构比较清晰的场景，会通过代码生成技术实现循环展开，以减少循环次数。
    >
    > 向量化执行了
    >
    > 
    >
    > SIMD被广泛地应用于文本转换、数据过滤、数据解压和JSON转换等场景。相较于单纯地使用CPU，利用寄存器暴力优化也算是一种降维打击了。