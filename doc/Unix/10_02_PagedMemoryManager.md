
基址极值管理存在的问题：

多道编程的内存管理模式里，以交换内存管理最为灵活和先进。它可以解决因程序所需空间增长而无法继续运行的困难，又可以实现动态多道编程。事实上，这种策略存在很多重大问题，而其中最重要的两个问题是空间浪费和程序大小受限。

1. 空间浪费
```
假定我们运行8个程序：A、B、C、D、E、F、G、H，其启动、内存需要和交换过程如下：
A启动，需占用内存200KB，分配空间1000KB～1199KB。
B启动，需占用内存100KB，分配空间1200KB～1299KB。
C启动，需占用内存300KB，分配空间1300KB～1599KB。
A结束，释放内存空间1000KB～1199KB。
D启动，需占用内存50KB，分配空间1000KB～1049KB。
E启动，需占用内存100KB，分配空间1600KB～1699KB。
C结束，释放内存空间1300KB～1599KB。
F启动，需占用内存200KB，分配空间1300KB～1499KB。
G启动，需占用内存50KB，分配空间1500KB～1549KB。
H启动，需占用内存200KB，无法分配空间！
在上述前7个进程执行序列后，当前内存中尚有200KB的闲置空间，分别处于地址1050KB～1199KB和1550KB～1599KB。
因为不连续，所以无法容纳进程H,而进程H的空间需求只有200KB！
```
随着程序在内存与磁盘间的交换，内存将变得越来越碎片化，即内存将被不同程序分割成尺寸大小无法使用的小片空间。散布在进程之间的闲置空间称为外部碎片。这是因为从进程的粒度来看，这种碎片处于进程空间的外面。这种碎片化过程也称为“外部碎片化“。随着进程的进进出出，外部碎片将浪费大量的内存空间。

我们可以采取一些措施来降低外部碎片的危害，例如，在寻找空间容纳新的进程时，可以按照某种算法，如最先适用(first fit)或者最佳适用(best fit)来进行。最佳适用就是找到一个能够容纳新程序的最小空间。而最先适用就是找到第1个可以容纳新进程的空间。实践证明，最先适用比最佳适用更好。虽然最佳适用的名字听上去很好，但因为每次都是最小适应，使得多出来的空间反而更加难以再次利用。但不管是最佳适用还是最先适用，这些算法都不能消除外部碎片。当然，如果实在不行，我们可以进行碎片整理，即通过移动进程在内存里面的位置将空闲空间连成一片。但是这种操作需要将进程导出到磁盘上，再重新加载，效率十分低下。在进行碎片整理的过程中，系统的响应延迟将显著增加。

---
2. 程序受限问题
交换的内存管理模式还存在：地址空间增长困难，其中有两层意思：
    1. 空间增长效率低下。通过交换，可以让程序的大小增长。即先把程序倒到磁盘上，再在内存寻找一片更大的空间将程序倒进来，从而扩展程序所占的空间。由于磁盘操作耗时，这种交换出去，再找一片更大的空间来增长程序空间的做法效率非常低。
    2. 空间增长存在天花板限制。交换所能带来的空间增长有限。这个限制就是单一程序不能超过物理内存空间（减去操作系统所占部分），尽管多个程序的总空间可以超过物理内存空间。

---

解决办法

空间碎片化的根源是每个程序的大小不一样，这样在空间分配时不存在一致性。解决的办法自然是将空间按照某种规定的大小进行分配。只要将虚拟内存与物理内存都分成大小一样的部分，称为页，然后按页进行内存分配，就可以克服外部碎片的问题。

程序增长有限则是因为一个程序需要全部加载到内存才能运行。而解决的办法就是使一个程序无须全部加载就可以运行。用分页也可以解决这个问题：只将当前需要的页面放在内存里，其他暂时不用的页面放在磁盘上，这样一个程序同时占用内存和磁盘，其增长空间就大大增加了。分页后，如果一个程序需要更多的空间，给其分配一个新页即可。

---
# 分页内存管理

分页系统的核心就是将虚拟内存空间和物理内存空间皆划分为大小相同的页面，如4KB、8KB或16KB等，并以页面作为内存空间的最小分配单位，一个程序的一个页面可以存放在任意一个物理页面里。这样，由于物理空间是页面的整数倍，并且空间分配以页面为单位，将不会再产生外部碎片。同时，由于一个虚拟页面可以存放在任何一个物理页面里，空间增长也容易解决：只需要分配额外的虚拟页面，并找到一个闲置的物理页面存放即可。<b>分页系统下，一个程序发出的虚拟地址由两部分组成：页面号和页内偏移值.</b>例如，对于32位寻址的系统，如果页面大小为4KB，则页面号占20位，页内偏移值占12位。

为了解决程序比内存大的问题，可以允许一个进程的部分虚拟页面存放在物理页面之外，也就是磁盘上。在需要访问这些外部虚拟页面时，再将其调入物理内存。由此，交换系统的所有缺陷均被克服。

## 地址翻译
分页系统要能够工作的前提是：对于任何一个虚拟页面，系统知道该页面是否在物理内存中，如果在的话，其对应的物理页面是哪个；如果不在的话，则产生一个系统中断(缺页中断)，并将该虚页从磁盘转到内存，然后将分配给它的物理页面号返回。也就是说，页面管理系统要能够将虚拟地址转换为物理地址。翻译过程:
```C++
if (虚拟页面非法、不在内存或者被保护) {
    陷入到操作系统错误服务程序
} else {
    将虚拟页面号转换为物理页面号
    根据物理页面号产生最终物理地址
}
```
<br>分页系统的核心是页面的翻译，即从虚拟页面到物理页面的映射。</b>而这个翻译过程由内存管理单元(MMU)完成。MMU接收CPU发出的虚拟地址，将其翻译为物理地址后发送给内存。内存单元按照该物理地址进行相应访问后读出或写入相关数据
<center>
    <img src="img/10_02_vaddr_2_phyaddr.png">
    <div>虚拟地址到物理地址的流向图</div>
</center>

<b>内存管理单元对虚拟地址的翻译只是对页面号的翻译，即将虚拟页面号翻译成物理页面号。而对于偏移值，则不进行任何操作。</b>因为虚拟页表和物理页表大小完全一样，虚拟页面里的偏移值和物理页面里的偏移值完全一样，无须翻译。

<b>内存管理单元是通过什么手段完成这种翻译的呢？查页表。</b>对于每个程序，内存管理单元都为其保存一个页表，该页表中存放的是虚拟页面到物理页面的映射。每当为一个虚拟页面寻找到一个物理页面后，就在页表里面增加一个记录来保留该虚拟页面到物理页面的映射关系。随着虚拟页面进出物理内存，页表的内容页不断发生变化。
在程序发出一个虚拟地址给内存管理单元后，内存管理单元首先将地址里面页号部分的字位分离出来，然后判断该虚拟页面是否有效，是否存放在内存，是否受到保护。
- 如果页面无效，即该虚拟页面不存在或没有在内存，也就是说该虚拟页面在物理内存里面没有对应。
- 如果该页面受到保护，即对该页面的访问被禁止，则产生一个系统中断来处理这些特殊情况。
- 对于无效页面访问，需要终止发出该无效访问的进程。
- 对于合法但不在物理内存中的页面，通过缺页中断将该虚拟页面放进物理内存。
- 对于受保护的页面，同样终止该进程。

如果页面有效且在物理内存，又没有受保护，则使用该虚拟页面号作为索引，找到页表中对应该虚拟页面的记录，读取其对应的物理页面号
<center>
    <img src="./img/10_02_translate_Vaddr2Phyaddr.png">
</center>
内存管理单元是怎么知道一个页面是否有效，是否被保护，是否在物理内存呢？这些信息储存在页表里面。页表不只是用来进行翻译，还用来进行页面的各种状态判断.

---
什么叫做虚拟页面非法呢？程序在加载前所使用的一切地址均是虚拟地址，即程序存在于虚拟空间。而虚拟空间的大小与系统的寻址长度有关。例如，32位寻址的系统虚拟地址空间为2^32-1，即一个程序最多可以有2^32-1条指令。但是一个程序可能没有这么多条指令。事实上，大部分程序都不会占满整个虚拟空间。有一部分虚拟空间是空的，即程序没有使用的部分。这部分空间就是非法虚拟空间。如果一个程序访问了这片空间，即判定为非法，而无须再判断该虚拟页面是否在物理内存。比如一个程序大小为100KB，如果该程序试图访问虚拟地址100KB以上的地址，即视为非法访问。进行这种访问的程序即为程序错误或失效。

## 页面翻译
页表的根本功能是提供从虚拟页面到物理页面的映射。页表的记录条数与虚拟页面数相同。例如，对于32位寻址的虚拟地址，如果页面大小为4KB，则虚拟页面数最多可以达到2^20，即1 048 576个虚拟页面。那么页表的记录条数就为1 048 576条。

内存管理单元依赖页表来进行一切与页面有关的管理活动。这些活动包括判断某一页面号是否在内存里，页面是否受到保护，页面是否非法空间等。因此，页表除了提供虚拟页面到物理页面的映射外，还记录这些相关信息。页表的一个记录所包括：
```
| 缓存禁止 ｜ 访问位 ｜ 修改位 ｜ 保护标识区 ｜ 在内存否 ｜ 物理页面号｜

页表记录内容举例
```
- 缓存禁止位用来指示该页面是否允许存放在缓存里。
- 访问位记录该页面是否被访问过(被读过或者被写过)。
- 修改位记录该页面自从加载到物理内存后是否被修改过。
- 保护标识位记录该页的受保护情况，如是否允许读、写、执行等。
- 在内存否则记录该虚拟页面是否已经在物理内存里。
- 物理页面号则是该虚拟页面对应的物理页面(如果该虚拟页面在物理内存)。

访问位和修改位是内存管理单元进行页面置换时依赖的信息。一个记录条通常还会有一个保留区(reserve area)，通常是存在的。设置保留区的目的是为以后有需要时增加信息用的。页表的特殊地位决定了它由硬件直接提供支持，即页表是一个硬件数据结构。

# 分页系统优缺点
分页系统不会产生外部碎片，一个进程占用的内存空间可以不是连续的，并且一个进程的虚拟页面在不需要的时候可以放在磁盘上。这样，在分页系统下，进程空间的增长和虚拟内存的实现都解决了。分页系统的另一个优点是可以共享小的地址，即页面共享，只需要在对应给定页面的页表项里做一个相关的记录即可。

分页系统也存在缺点。第一个缺点就是页表很大，占用了大量的内存空间。例如，对于32位寻址、页面尺寸为4KB的分页系统来说，页表将有1 048 576个记录。每个记录又要占用多个字节，这样，一个页表所占的内存空间相当大。

有没有办法减少页表的尺寸呢？可以选择多级页表的方式。既然一个程序可以分解为一个个页面，并将部分页面存放在磁盘上而降低其内存占用空间，页表也可以采用同样的方式处理，即将页表分为一个个页面，不需要的页面也放在磁盘上，内存里只存放需要的页面。

## 多级页表

# 翻译速度

# 缺页中断

# 锁住页面

# 内存抖动
