
基址极值管理存在的问题：

多道编程的内存管理模式里，以交换内存管理最为灵活和先进。它可以解决因程序所需空间增长而无法继续运行的困难，又可以实现动态多道编程。事实上，这种策略存在很多重大问题，而其中最重要的两个问题是空间浪费和程序大小受限。

1. 空间浪费
```
假定我们运行8个程序：A、B、C、D、E、F、G、H，其启动、内存需要和交换过程如下：
A启动，需占用内存200KB，分配空间1000KB～1199KB。
B启动，需占用内存100KB，分配空间1200KB～1299KB。
C启动，需占用内存300KB，分配空间1300KB～1599KB。
A结束，释放内存空间1000KB～1199KB。
D启动，需占用内存50KB，分配空间1000KB～1049KB。
E启动，需占用内存100KB，分配空间1600KB～1699KB。
C结束，释放内存空间1300KB～1599KB。
F启动，需占用内存200KB，分配空间1300KB～1499KB。
G启动，需占用内存50KB，分配空间1500KB～1549KB。
H启动，需占用内存200KB，无法分配空间！
在上述前7个进程执行序列后，当前内存中尚有200KB的闲置空间，分别处于地址1050KB～1199KB和1550KB～1599KB。
因为不连续，所以无法容纳进程H,而进程H的空间需求只有200KB！
```
随着程序在内存与磁盘间的交换，内存将变得越来越碎片化，即内存将被不同程序分割成尺寸大小无法使用的小片空间。散布在进程之间的闲置空间称为外部碎片。这是因为从进程的粒度来看，这种碎片处于进程空间的外面。这种碎片化过程也称为“外部碎片化“。随着进程的进进出出，外部碎片将浪费大量的内存空间。

我们可以采取一些措施来降低外部碎片的危害，例如，在寻找空间容纳新的进程时，可以按照某种算法，如最先适用(first fit)或者最佳适用(best fit)来进行。最佳适用就是找到一个能够容纳新程序的最小空间。而最先适用就是找到第1个可以容纳新进程的空间。实践证明，最先适用比最佳适用更好。虽然最佳适用的名字听上去很好，但因为每次都是最小适应，使得多出来的空间反而更加难以再次利用。但不管是最佳适用还是最先适用，这些算法都不能消除外部碎片。当然，如果实在不行，我们可以进行碎片整理，即通过移动进程在内存里面的位置将空闲空间连成一片。但是这种操作需要将进程导出到磁盘上，再重新加载，效率十分低下。在进行碎片整理的过程中，系统的响应延迟将显著增加。

---
2. 程序受限问题
交换的内存管理模式还存在：地址空间增长困难，其中有两层意思：
    1. 空间增长效率低下。通过交换，可以让程序的大小增长。即先把程序倒到磁盘上，再在内存寻找一片更大的空间将程序倒进来，从而扩展程序所占的空间。由于磁盘操作耗时，这种交换出去，再找一片更大的空间来增长程序空间的做法效率非常低。
    2. 空间增长存在天花板限制。交换所能带来的空间增长有限。这个限制就是单一程序不能超过物理内存空间（减去操作系统所占部分），尽管多个程序的总空间可以超过物理内存空间。

---

解决办法

空间碎片化的根源是每个程序的大小不一样，这样在空间分配时不存在一致性。解决的办法自然是将空间按照某种规定的大小进行分配。只要将虚拟内存与物理内存都分成大小一样的部分，称为页，然后按页进行内存分配，就可以克服外部碎片的问题。

程序增长有限则是因为一个程序需要全部加载到内存才能运行。而解决的办法就是使一个程序无须全部加载就可以运行。用分页也可以解决这个问题：只将当前需要的页面放在内存里，其他暂时不用的页面放在磁盘上，这样一个程序同时占用内存和磁盘，其增长空间就大大增加了。分页后，如果一个程序需要更多的空间，给其分配一个新页即可。

---
# 分页内存管理

分页系统的核心就是将虚拟内存空间和物理内存空间皆划分为大小相同的页面，如4KB、8KB或16KB等，并以页面作为内存空间的最小分配单位，一个程序的一个页面可以存放在任意一个物理页面里。这样，由于物理空间是页面的整数倍，并且空间分配以页面为单位，将不会再产生外部碎片。同时，由于一个虚拟页面可以存放在任何一个物理页面里，空间增长也容易解决：只需要分配额外的虚拟页面，并找到一个闲置的物理页面存放即可。<b>分页系统下，一个程序发出的虚拟地址由两部分组成：页面号和页内偏移值.</b>例如，对于32位寻址的系统，如果页面大小为4KB，则页面号占20位，页内偏移值占12位。

为了解决程序比内存大的问题，可以允许一个进程的部分虚拟页面存放在物理页面之外，也就是磁盘上。在需要访问这些外部虚拟页面时，再将其调入物理内存。由此，交换系统的所有缺陷均被克服。

## 地址翻译
分页系统要能够工作的前提是：对于任何一个虚拟页面，系统知道该页面是否在物理内存中，如果在的话，其对应的物理页面是哪个；如果不在的话，则产生一个系统中断(缺页中断)，并将该虚页从磁盘转到内存，然后将分配给它的物理页面号返回。也就是说，页面管理系统要能够将虚拟地址转换为物理地址。翻译过程:
```C++
if (虚拟页面非法、不在内存或者被保护) {
    陷入到操作系统错误服务程序
} else {
    将虚拟页面号转换为物理页面号
    根据物理页面号产生最终物理地址
}
```
<br>分页系统的核心是页面的翻译，即从虚拟页面到物理页面的映射。</b>而这个翻译过程由内存管理单元(MMU)完成。MMU接收CPU发出的虚拟地址，将其翻译为物理地址后发送给内存。内存单元按照该物理地址进行相应访问后读出或写入相关数据
<center>
    <img src="img/10_02_vaddr_2_phyaddr.png">
    <div>虚拟地址到物理地址的流向图</div>
</center>

<b>内存管理单元对虚拟地址的翻译只是对页面号的翻译，即将虚拟页面号翻译成物理页面号。而对于偏移值，则不进行任何操作。</b>因为虚拟页表和物理页表大小完全一样，虚拟页面里的偏移值和物理页面里的偏移值完全一样，无须翻译。

<b>内存管理单元是通过什么手段完成这种翻译的呢？查页表。</b>对于每个程序，内存管理单元都为其保存一个页表，该页表中存放的是虚拟页面到物理页面的映射。每当为一个虚拟页面寻找到一个物理页面后，就在页表里面增加一个记录来保留该虚拟页面到物理页面的映射关系。随着虚拟页面进出物理内存，页表的内容页不断发生变化。
在程序发出一个虚拟地址给内存管理单元后，内存管理单元首先将地址里面页号部分的字位分离出来，然后判断该虚拟页面是否有效，是否存放在内存，是否受到保护。
- 如果页面无效，即该虚拟页面不存在或没有在内存，也就是说该虚拟页面在物理内存里面没有对应。
- 如果该页面受到保护，即对该页面的访问被禁止，则产生一个系统中断来处理这些特殊情况。
- 对于无效页面访问，需要终止发出该无效访问的进程。
- 对于合法但不在物理内存中的页面，通过缺页中断将该虚拟页面放进物理内存。
- 对于受保护的页面，同样终止该进程。

如果页面有效且在物理内存，又没有受保护，则使用该虚拟页面号作为索引，找到页表中对应该虚拟页面的记录，读取其对应的物理页面号
<center>
    <img src="./img/10_02_translate_Vaddr2Phyaddr.png">
</center>
内存管理单元是怎么知道一个页面是否有效，是否被保护，是否在物理内存呢？这些信息储存在页表里面。页表不只是用来进行翻译，还用来进行页面的各种状态判断.

---
什么叫做虚拟页面非法呢？程序在加载前所使用的一切地址均是虚拟地址，即程序存在于虚拟空间。而虚拟空间的大小与系统的寻址长度有关。例如，32位寻址的系统虚拟地址空间为2^32-1，即一个程序最多可以有2^32-1条指令。但是一个程序可能没有这么多条指令。事实上，大部分程序都不会占满整个虚拟空间。有一部分虚拟空间是空的，即程序没有使用的部分。这部分空间就是非法虚拟空间。如果一个程序访问了这片空间，即判定为非法，而无须再判断该虚拟页面是否在物理内存。比如一个程序大小为100KB，如果该程序试图访问虚拟地址100KB以上的地址，即视为非法访问。进行这种访问的程序即为程序错误或失效。

## 页面翻译
页表的根本功能是提供从虚拟页面到物理页面的映射。页表的记录条数与虚拟页面数相同。例如，对于32位寻址的虚拟地址，如果页面大小为4KB，则虚拟页面数最多可以达到2^20，即1 048 576个虚拟页面。那么页表的记录条数就为1 048 576条。

内存管理单元依赖页表来进行一切与页面有关的管理活动。这些活动包括判断某一页面号是否在内存里，页面是否受到保护，页面是否非法空间等。因此，页表除了提供虚拟页面到物理页面的映射外，还记录这些相关信息。页表的一个记录所包括：
```
| 缓存禁止 ｜ 访问位 ｜ 修改位 ｜ 保护标识区 ｜ 在内存否 ｜ 物理页面号｜

页表记录内容举例
```
- 缓存禁止位用来指示该页面是否允许存放在缓存里。
- 访问位记录该页面是否被访问过(被读过或者被写过)。
- 修改位记录该页面自从加载到物理内存后是否被修改过。
- 保护标识位记录该页的受保护情况，如是否允许读、写、执行等。
- 在内存否则记录该虚拟页面是否已经在物理内存里。
- 物理页面号则是该虚拟页面对应的物理页面(如果该虚拟页面在物理内存)。

访问位和修改位是内存管理单元进行页面置换时依赖的信息。一个记录条通常还会有一个保留区(reserve area)，通常是存在的。设置保留区的目的是为以后有需要时增加信息用的。页表的特殊地位决定了它由硬件直接提供支持，即页表是一个硬件数据结构。

# 分页系统优缺点
分页系统不会产生外部碎片，一个进程占用的内存空间可以不是连续的，并且一个进程的虚拟页面在不需要的时候可以放在磁盘上。这样，在分页系统下，进程空间的增长和虚拟内存的实现都解决了。分页系统的另一个优点是可以共享小的地址，即页面共享，只需要在对应给定页面的页表项里做一个相关的记录即可。

分页系统也存在缺点。第一个缺点就是页表很大，占用了大量的内存空间。例如，对于32位寻址、页面尺寸为4KB的分页系统来说，页表将有1 048 576个记录。每个记录又要占用多个字节，这样，一个页表所占的内存空间相当大。

有没有办法减少页表的尺寸呢？可以选择多级页表的方式。既然一个程序可以分解为一个个页面，并将部分页面存放在磁盘上而降低其内存占用空间，页表也可以采用同样的方式处理，即将页表分为一个个页面，不需要的页面也放在磁盘上，内存里只存放需要的页面。

## 多级页表
在多级页表结构下，页表根据存放的内容可分为：顶级页表、一级页表、二级页表、三级页表等。顶级页表里面存放的是一级页表的信息，一级页表里面存放的是二级页表的信息，以此类推，到最后一级页表存放的才是虚拟页面到物理页面的映射。一个程序在运行时其顶级页表常驻内存，而次级页表则按需要决定是否存放在物理内存。

多级页表为什么占用的内存空间少呢？因为大部分次级页表会放到磁盘上，而放在内存里面的页表较少。因此，内存占用少。
多级页表有什么缺点呢？它降低了系统的速度。因此每次内存访问都变成多次内存访问。对于二级页表，一次内存访问变成了三次内存访问。如果次级页表不在内存，还需要加上一次磁盘访问。这样，系统的速度将大为下降。对于级数更多的页表来说，内存访问速度额下降将更加明显。

# 反转页表

在不增加页表级数的情况下降低页表所占的空间呢？有，使用反转页表。正常的页表存放的是从虚拟页面到物理页面的映射；而反转页表存放的是物理页面到虚拟页面的映射。这样，由于物理内存比虚拟内存小很多，页表的尺寸将大为减少。

由于反转页表存放的是物理地址到虚拟地址的映射，而CPU发出的地址却是虚拟地址，这就造成页表查找困难。不过，这个问题可以通过散列来解决，即将虚拟页号散列到物理页号，然后以这个散列出来的物理页号作为索引在反转页表里面查找。由于虚拟页面远多于物理页面的缘故，多个虚拟页号将很可能散列到同一个物理页号对应的记录里。散列后，仍然需要检查该虚拟页面是否在物理内存内，而这种检查需要进行多次内存访问。如果使用开放式散列，则散列表的尺寸将随着程序使用的虚拟页面数的增加而增加。

# 缺页中断

在分页系统里，一个虚拟页面既有可能在物理内存，也有可能保存在磁盘上。如果CPU发出的虚拟地址对应的页面不在物理内存，就将产生一个缺页中断。而缺页中断服务程序负责将需要的虚拟页面找到并加载到内存。

缺页中断程序是如何知道虚拟页面在磁盘的什么地方呢？它当然不知道。但它知道产生缺页中断进程所对应的源程序文件名和产生缺页中断的虚拟地址。这样，缺页中断服务程序首先根据虚拟地址计算出该地址在相应程序文件里面的位移量或偏移量（off-set），然后要求文件系统在这个偏移量的地方进行文件读操作。

# 锁住页面

如果发生缺页中断，就需要从磁盘上将需要的页面调入内存。如果内存没有多余的空间，就需要在现有的页面里选择一个页面进行替换。使用不同的更换算法，页面更换的顺序将各不相同。

如果一个页面非常重要，我们知道它将被经常访问，也可以把它锁住，从而防止不必要的页面替换。

如何把页面锁在内存里呢？很简单，只需要对该页面做出特殊标记即可。即我们在页表的相应记录项里增加一项标志。如果该标志被设置，缺页中断服务程序在选择被替换的页面时将跳过该页面。

# 页面尺寸

分页系统的一个考虑因素就是页面应该设计为多大？如果太大，可能造成浪费。因为一个程序的最后一个页面很有可能是不满的。最好的情况是一个程序的大小正好是页面大小的整数倍；最坏的情况则是页面的整数倍多1条指令，多出来的这条指令就要占用一个页面，造成一个页面的绝大部分空间浪费。在平均情况下，最后一个页面有半个页面被浪费。这种浪费称为内部碎片，即一个进程内部的碎片空间。

假定p表示页面大小，e表示页表一个记录的大小，s表示程序的平均尺寸，则整个系统浪费的空间可由下面的表达式计算：
其中s·e/p是一个程序页表所占的内存空间，而p/2则是一个程序平均浪费的页面空间（半个页面）。对上述表达式求极小值就可以得出页面尺寸p的最优大小为：

# 内存抖动

在更换页面时，如果更换的页面是一个很快就会被再次访问的页面，则在此次缺页中断后很快又会发生新的缺页中断。在最坏情况下，每次新的访问都是对一个不在内存的页面进行访问，即每次内存访问都产生一次缺页中断，这样每次内存访问皆变成一次磁盘访问，而由于磁盘访问速度比内存可以慢一百万倍，因此整个系统的效率急剧下降。这种现象就称为内存抖动，或者抽打、抽筋（tras-hing）。

可以通过仔细设计页面更换算法来降低内存抖动的概率，但却不能完全避免。例如，如果一个系统运行着很多进程，而且这些进程都比较大，即每个程序所占的虚拟空间都较大。这样就有可能造成某个程序频繁需要的页面不能完全放在内存里，造成该程序运行时的内存抖动。又例如，虽然系统只有一个程序，但是该程序频繁访问的页面数超过物理内存的页面数，这样也将造成内存抖动。

发生内存抖动时，系统的效率将与停滞差不多，几乎看不到任何进展的迹象。

有什么办法解决内存抖动呢？
1. 页面替换策略失误，当然可以修改替换算法
2. 运行的程序太多，造成至少一个程序无法同时将所有频繁访问的页面调入内存，则需要降低多道编程的度数。通过减少同时运行的程序个数而使得每个程序都有足够的资源来运行而不产生抖动抖动。例如，我们可以把其中一些进程全部交换到磁盘上，把空出来的空间给其他尚在内存的进程使用。这种降低多道编程度数的做法也称为负载平衡
3. 有时候即使进行负载平衡也不一定能够消除内存抖动。例如，如果是一个进程的频繁访问页面就超过物理内存的页面数，即使降低多道编程度数，系统仍将抖动。这个时候解决的办法只有两个：一是终止该进程，永远不许其运行；二是增加物理内存的容量，就是开疆拓土。

增加物理页面数反而导致缺页次数增加的现象称为比莱迪异常（Beladys anomaly）。

如果我们发现在增加物理页面数后程序的效率不升反降，则有可能发生了比莱迪异常。这个时候的应对策略是继续增加物理页面数，直到该现象消失为止。
也可以改变页面替换算法来避免比莱迪异常。例如，改先进先出算法为LRU或工作集算法即可避免比莱迪异常