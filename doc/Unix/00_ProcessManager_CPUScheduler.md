# 进程相关时间概念

```
		|----------------- Waiting Time ---------------|----------------- Burst Time ---------|
    Arrival Time															      Complete Time
|-----------------|							|-----------------|					|-----------------|
|	Ready         |				->			|	   Ready	 |			->	    |     Complete	  |
|-----------------|							|-----------------|					|-----------------|	
```

```
CT - AT = WT + BT
TAT = CT - AT
WT = TAT - BT

其中：AT代表Arrival Time， BT代表Burst Time, TAT代表Turn Around Time
```



**1. 到达时间**

进程进入就绪队列的时间称为到达时间。

**2. 突发时间(Burst Time)**

也就是BT(Burst Time)，CPU执行整个过程所需的总时间称为突发时间。 这不包括等待时间。 即使在执行之前计算一个过程的执行时间也是令人困惑的，因此基于突发时间的调度问题无法在现实中实现。

**3. 完成时间**
进程进入完成状态的时间或进程完成其执行的时间称为完成时间。

**4. 周转时间**
也就是TAT(Turn Around Time)，该过程从抵达到完成所花费的时间总量称为周转时间。

**5. 等待时间**
进程等待CPU分配的总时间称为等待时间。

**6. 响应时间**
到达时间和进程首次获取CPU的时间之间的差异称为响应时间。

## 参考资料

1. [与进程有关的时间 - 易百教程]([与进程有关的时间 - 操作系统教程 (yiibai.com)](https://www.yiibai.com/os/os-various-time-related-to-the-process.html))

# CPU调度算法



## SFJ(最短作业优先)

SJF调度算法根据其突发时间安排进程。在SJF调度中，就绪队列中可用进程列表中的突发时间最短的进程将在下一个进行调度。然而，预测一个过程所需的突发时间是非常困难的，因此这个算法在系统中很难实现。

**SJF的优势**

- 最大吞吐量
- 最低的平均等候时间和周转时间

**SJF的缺点**

- 可能会面临饥饿问题
- 这是不可实现的，因为一个进程的确切爆发时间不能预先知道。

### 参考资料

1. [操作系统最短作业优先(SJF)调度 - 易百教程](https://www.yiibai.com/os/os-sjf-scheduling.html)



## MLFQ(多级反馈队列)

多级反馈队列需要解决两方面的问题。

1. 优化周转时间。通过先执行短工作可以实现优化周转时间。通常操作系统不知道工作要运行多久，而这又是SJF(或STCF)等算法所必需的。
2. 降低响应时间，因为MLFQ希望给交互用户(如用户坐在屏幕前，等着进程结束)很好的交互体验，因此需要降低响应时间。像轮转这样的算法虽然降低了响应时间，周转时间却很差。

<b><font color=FFB533>所以这里的问题是：<br/>1. 通常我们对进程一无所知，应该如何构建调度程序来实现优化周转时间和降低响应时间的目标？也就是，要在没有先验经验的情况下，实现上述目标。多级反馈队列用历史经验预测未来。<br/>2. 调度程序如何在运行过程中学习进程的特征，从而做出更好的调度决策？
</font></b>



MLFQ中有许多独立的队列(queue)，每个队列有不同的优先级(priority level)。任何时刻，一个工作只能存在于一个队列中。MLFQ总是优先执行较高优先级的工作(即在较高级队列中的工作)。每个队列中可能会有多个工作，具有同样的优先级。相同队列中的多个工作采用轮转调度。至此，我们得到了MLFQ的两条基本规则。

- **规则1**：如果A的优先级 > B的优先级，运行A（不运行B）。
- **规则2**：如果A的优先级 = B的优先级，轮转运行A和B。

因此，<b>MLFQ调度策略的关键在于如何设置优先级。</b>



### 尝试1：如何改变优先级

在一个工作的生命周期中，MLFQ如何改变其优先级(在哪个队列中)。要做到这一点，我们必须记得工作负载：既有运行时间很短、频繁放弃CPU的交互型工作，也有需要很多CPU时间、响应时间却不重要的长时间计算密集型工作。下面是我们第一次尝试优先级调整算法。

- **规则3**：工作进入系统时，放在最高优先级(最上层队列)。

- **规则4a**：工作用完整个时间片后，降低其优先级(移入下一个队列)。

  > 不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级(规则3)。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了(规则4a)。通过这种方式，MLFQ近似于SJF。

- **规则4b**：如果工作在其时间片以内主动释放CPU，则优先级不变。

  > 确保交互性工作快速执行，降低响应时间。
  >
  > 交互型工作B每执行1ms便需要进行I/O操作，它与长时间运行的工作A争CPU。MLFQ算法保持B在最高优先级，因为B总是让出CPU。如果B是交互型工作，MLFQ就进一步实现了它的目标，让交互型工作快速运行。



上述实现了一个基本的MLFQ，看起来，它可以实现长工作之间可以公平地分享CPU，又能给短工作或交互型工作很好的响应时间。然而，这种算法有一些非常严重的缺点：

> 1. 存在饥饿(starvation)问题。如果系统有太多交互型工作，就会不断占用CPU，导致长工作永远无法得到CPU(饿死)。
> 2. 聪明的用户会重写程序，愚弄调度程序(game the scheduler)。愚弄调度程序指的是用一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源。上述算法对如下的攻击束手无策：进程在时间片用完之前，调用一个I/O操作(比如访问一个无关的文件)，从而主动释放CPU。如此便可以保持在高优先级，占用更多的CPU时间。做得好时(比如，每运行99%的时间片时间就主动放弃一次CPU)，它可以几乎独占CPU。



### 尝试2：提升优先级(饥饿问题)

让我们试着改变之前的规则，看能否避免饥饿问题。要让CPU密集型工作也可以执行(即使不多)，我们能做些什么？一个简单的思路是周期性地提升所有工作的优先级。可以有很多方法做到，最简单的方式是：将所有工作扔到最高优先级队列，于是有了如下的新规则：

- **规则5**：经过一段时间*S*，就将系统中所有工作重新加入最高优先级队列。

新规则一下解决了两个问题。首先，进程不会饿死——在最高优先级队列中，它会以轮转的方式，与其他高优先级工作分享CPU，从而最终获得执行。其次，如果一个CPU密集型工作变成了交互型，当它优先级提升时，调度程序会正确对待它。

添加时间段*S*导致了明显的问题：*S*的值应该如何设置？德高望重的系统研究员 John Ousterhout曾将这种值称为“巫毒常量(voo-doo constant)，因为似乎需要一些黑魔法才能正确设置。如果*S*设置得太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的CPU时间比例。



 ### 尝试3：采用更好的计时方式

现在还有一个问题要解决：如何阻止调度程序被愚弄？可以看出，这里的元凶是规则4a和4b，导致工作在时间片以内释放CPU，就保留它的优先级。那么应该怎么做？解决方案是为MLFQ的每层队列提供更完善的CPU计时方式(accounting)。调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。只要进程用完了自己的配额，就将它降到低一优先级的队列中去。不论它是一次用完的，还是拆成很多次用完。重写规则4a和4b。

- **规则4**：一旦工作用完了其在某一层中的时间配额(无论中间主动放弃了多少次CPU)，就降低其优先级(移入低一级队列)。



### MLFQ调优和其他问题

关于MLFQ调度算法还有一些问题。其中一个大问题是如何配置一个调度程序，例如，配置多少队列？每一层队列的时间片配置多大？为了避免饥饿问题以及进程行为改变，应该多久提升一次进程的优先级？这些问题都没有显而易见的答案，只有利用对工作负载的经验以及后续对调度程序的调优。

例如，大多数的MLFQ变体都支持不同队列可变的时间片长度。高优先级队列通常只有较短的时间片(比如10ms或者更少)，因而这一层的交互工作可以更快地切换。相反，低优先级队列中更多的是CPU密集型工作，配置更长的时间片会取得更好的效果。

Solaris的MLFQ实现(时分调度类TS)很容易配置，它提供了一组表来决定进程在其生命周期中如何调整优先级，每层的时间片多大，以及多久提升一个工作的优先级。管理员可以通过这些表，让调度程序的行为方式不同。该表默认有60层队列，时间片长度从20ms(最高优先级)，到几百ms(最低优先级)，每一秒左右提升一次进程的优先级。

有些采用数学公式来调整优先级。例如，FreeBSD调度程序(4.3版本)，会基于当前进程使用了多少CPU，通过公式计算某个工作的当前优先级。另外，使用量会随时间衰减，这提供了期望的优先级提升。

---

### 综述

多级反馈队列需要解决两方面的问题。

1. 优化周转时间。通过先执行短工作可以实现优化周转时间(类似于SJF算法)。
2. 降低响应时间，保持交互体验。

MLFQ的使用的优化规则：

- **规则1**：如果A的优先级 > B的优先级，运行A(不运行B)。

- **规则2**：如果A的优先级 = B的优先级，轮转运行A和B。

- **规则3**：工作进入系统时，放在最高优先级(最上层队列)。

  > 假设短工作，先执行，优化周转时间，如果是短工作很快便执行完成，如果是长工作通过规则4降低优先级

- **规则 4**：一旦工作用完了其在某一层中的时间配额(无论中间主动放弃了多少次CPU)，就降低其优先级(移入低一级队列)。

  > 采用更好的计时方式，避免愚弄调试程序问题。

- **规则5**：经过一段时间*S*，就将系统中所有工作重新加入最高优先级队列。

  > 避免饿死问题

---

### 参考资料

1. [操作系统导论：多级反馈队列 - 知乎](https://zhuanlan.zhihu.com/p/367636084)



## CFS(完全公平调度算法)

完全公平调度算法体现在对待每个进程都是公平的，那么怎么才能做到完全公平呢？有一个比较简单的方法就是：让每个进程都运行一段相同的时间片，这就是 基于时间片轮询调度算法。由于每个时间片都是相等的，所以理论上每个进程都能获得相同的CPU运行时间。这个算法看起来很不错，但存在两个问题：
1. 不能按权重分配不同的运行时间，例如有些进程权重大的应该获得更多的运行时间。
2. 每次调度时都需要遍历运行队列中的所有进程，找到优先级最大的进程运行，时间复杂度为O(n)。



### 基本原理

为了解决上面两个问题，Linux内核的开发者创造了完全公平调度算法。在Linux内核2.6.23版本开始采用CFS进程调度器。它的基本原理是这样的：

1. 设定一个调度周期：目标是让每个进程在这个周期内至少有机会运行一次，换一种说法就是每个进程等待CPU的时间最长不超过这个调度周期。
2. 分配CPU使用权：根据进程的数量，大家平分这个调度周期内的CPU使用权，由于进程的优先级即nice值不同，分割调度周期的时候要加权。
3. 虚拟运行时间：每个进程的累计运行时间保存在自己的`vruntime`字段里，哪个进程的`vruntime`最小就获得本轮运行的权利。

为了实现完全公平调度算法，为进程定义两个时间:
$$
\begin{array}{l}
实际运行时间 &=& 调度周期 * 进程权重 / 所有进程权重之和 \\
\\
虚拟运行时间 &=& 实际运行时间 * 1024 / 进程权重 \\
&=& (调度周期 * 进程权重 / 所有进程权重之和) * 1024 / 进程权重 \\
&=& 调度周期 * 1024 / 所有进程总权重 \\
\end{array}
$$
可以看出，在一个调度周期里，所有进程的虚拟运行时间是相同的。所以在进程调度时，只需要找到 虚拟运行时间最小的进程调度运行即可。为了能够快速找到 虚拟运行时间最小的进程，Linux 内核使用红黑树保存可运行的进程，而比较的键值就是进程的虚拟运行时间。红黑树是一种自平衡二叉查找树，只需要获取红黑树的最左节点即可查找到最小节点，时间复杂度为$O(logN)$。



### 参考资料

1. [Linux 完全公平调度算法](https://github.com/liexusong/linux-source-code-analyze/blob/master/cfs-scheduler.md)



## 组调度

