1. 获取主元

    ​	1.1. 将n个元素按顺序分为n/5个组, 每组5个元素
    ​	1.2. 对于n/5个组中的每一组使用插入排序找到它们各自的中位数
    ​	1.3. 对于 1.2 中找到的所有中位数，调用BFPRT算法求出它们的中位数,作为主元

2. 以选取的主元为分界点，把小于主元的放在左边，大于主元的放在右边
3. 判断主元的位置与 k 的大小，有选择的对左边或右边递归



## 时间复杂度分析

BFPRT 算法在最坏情况下的时间复杂度是 $O(n)$，下面予以证明。令 $T(n)$ 为所求的时间复杂度，则有：

$T(n)≤T(\frac n 5)+T(\frac {7n}{10})+c⋅n \tag {c 为一个正常数} $

其中：

- $T(\frac n 5)$ 获取主元，n 个元素，5 个一组，共有 $⌊\frac n5⌋$ 个中位数；
- $T(\frac {7n}{10})$ 来自 `bfprt()`，在 $⌊\frac n5⌋$ 个中位数中，主元 x 大于其中 $\frac 12⋅\frac n5=\frac n{10}$ 的中位数，而每个中位数在其本来的 5 个数的小组中又大于或等于其中的 3 个数，所以主元 x 至少大于所有数中的 $\frac n{10}⋅3=\frac {3n}{10}$ 个。即划分之后，任意一边的长度至少为 $\frac 3{10}$，在最坏情况下，每次选择都选到了 $\frac 7{10}$ 的那一部分。
- $c⋅n$ 来自其它操作，比如 插入排序以及获取主元和 Partition里所需的一些额外操作。



参考资料

- [BFPRT 算法(TOP-K 问题)](https://segmentfault.com/a/1190000008322873)

