# 图
可以分为有向图和无向图。如果给图的每条边规定一个方向，那么这样的图就是有向图，它的边为有向边, 有向边就像城市里的单向路，只能沿着一个方向前进。无向图中的边都没有方向，它的边称为无向边。连接两个节点A、B的无向边可以看成两条有向边，分别由A指向B及由B指向A。图还可以分为有权图和无权图。在有权图中，每条边都有一个数值权重，用来表示两个节点的某种关系，如两个节点的距离等。在无权图中所有的边都没有权重。

---
通常，图可以用邻接表或邻接矩阵表示。如果一个图是用邻接矩阵表示的，那么判断两个节点之间是否有边相连就非常简单，只需要判断矩阵中对应位置是1还是0即可，时间复杂度为`O(1)`。但如果一个图中的节点数目非常大但比较稀疏(大部分节点之间没有边)，那么邻接表的空间效率更高。

广度优先搜索能够保证在无权图中从某个起始节点出发用最短的距离到达目标节点。在无权图中，两个节点的距离通常是连通两个节点的路径经过的节点的数目。深度优先搜索从一个节点到达另一个节点并不能保证一定沿着最短路径。

由于深度优先搜索沿着相邻节点的边一直纵向搜索下去，因此很容易就能知道从起始节点到目标节点的路径所经过的所有节点。

---
解题经验：

如果面试题要求在无权图中找出两个节点之间的最短距离，那么广度优先搜索可能是更合适的算法。如果面试题要求找出符合条件的路径，那么深度优先搜索可能是更合适的算法。

树是一类特殊的图，树中一定不存在环。但图不一样，图中可能包含环。当沿着图中的边搜索一个图时，一定要确保程序不会因为沿着环的边不断在环中搜索而陷入死循环。避免死循环的办法是记录已经搜索过的节点，在访问一个节点之前先判断该节点之前是否已经访问过，如果之前访问过那么这次就略过不再重复访问。

假设一个图有v个节点、e条边。不管是采用广度优先搜索还是深度优先搜索，每个节点都只会访问一次，并且会沿着每条边判断与某个节点相邻的节点是否已经访问过，因此时间复杂度是`O(v+e)`

## 拓扑排序

给定一个包含n个节点的有向图G，它的节点编号的一种排列，如果满足：
> 对于图G中的任意一条有向边`(u,v)`, u在排列中都出现在v的前面。

那么, 称该排列是图G的<b>拓扑排序</b>。根据上述的定义，可以得出两个结论：
1. 如果图G中存在环(即图G不是有向无环图)，那么图G不存在拓扑排序。这是因为假设图中存在环$x_1,x_2,⋯ ,x_n$, 那么 $x_1$在排列中必须出现在$x_n$的前面，但$x_n$同时也必须出现在$x_1$的前面，因此不存在一个满足要求的排列，也就不存在拓扑排序；
2. 如果图G是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图G值包含n个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序。

<b><font color=FF8D33>一个有向无环图可以有一个或多个拓扑排序序列，但无向图或有环的有向图都不存在拓扑排序。</font></b>

入度和出度。节点v的入度指的是以节点v为终点的边的数目，而节点v的出度是指以节点v为起点的边的数目。

一种常用的拓扑排序算法是每次从有向无环图中取出一个入度为0的节点添加到拓扑排序序列之中，然后删除该节点及所有以它为起点的边。重复这个步骤，直到图为空或图中不存在入度为0的节点。如果最终图为空，那么图是有向无环图，此时就找到了该图的一个拓扑排序序列。如果最终图不为空并且已经不存在入度为0的节点，那么图中一定有环。

## 并查集
并查集是一种树形的数据结构，用来表示不相交集合的数据。并查集中的每个子集是一棵树，每个元素是某棵树中的一个节点，树中的每个节点有一个指向父节点的指针，树的根节点的指针指向它自己。并查集经常用来解决图的动态连接问题。

进行路径压缩优化的并查集中的每次查找和合并操作的时间复杂度为$ o (\alpha(n))$，其中$\alpha(n)$在n十分大时还是小于5，因此平均运行时间是一个极小的常数。

# 树
不管是哪种深度优先搜索算法，也不管是递归代码还是迭代代码，如果二叉树有n个节点，那么它们的时间复杂都是$O(n)$。如果二叉树的深度为h，那么它们的空间复杂度都是$O(h)$。在二叉树中，二叉树的深度h的最小值是$log_2(n+1)$，最大值为n。

## 二叉搜索树

二叉搜索树是一类特殊的二叉树，它的左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点。

# 回溯法
<b>回溯法解决问题的过程实质上是在树形结构中从根节点开始进行深度优先遍历。</b>通常，回溯法的深度优先遍历用递归代码实现。如果在前往某个节点时对问题的解的状态进行了修改，那么在回溯到它的父节点时要记得清除相应的修改

由于回溯法是在所有选项形成的树上进行深度优先遍历，如果解决问题的步骤较多或每个步骤都面临多个选项，那么遍历整棵树将需要较多的时间。如果明确知道某些子树没有必要遍历，那么在遍历时应该避开这些子树以优化效率。<b>通常将使用回溯法时避免遍历不必要的子树的方法称为剪枝</b>。
