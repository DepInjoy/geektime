
# 树
树是由节点构成的数据结构。
- 每棵树都有一个根节点。（事实上，在图论中这并不必要，但是在编程中，特别是在编程面试中，我们通常这么做)
- 根节点有0个或多个子节点。
- 每个子节点有0个或多个子节点，以此类推。

树不应包括环路。节点可以有序或无序排列，可以包含任何类型的值，同时也可以包括或不包括指向父节点的指针。
树节点Node的一个简单实现如下：
```C++
class Node {
    public String name;
    public Node[] children;
}
```
树的遍历：
中序遍历是指先访问（通常也会打印）左子树，然后访问当前节点，最后访问右子树。
```C++
void inOrderTraversal(TreeNode node) {
    if (node != null) {
        inOrderTraversal(node.left);
        visit(node);
        inOrderTraversal(node.right);
    }
}
```
当在二叉搜索树上执行遍历时，它以升序访问节点。因此命名为“中序遍历”。

前序遍历先访问当前节点，再访问其子节点。因此命名为“前序遍历”。
```C++
void preOrderTraversal(TreeNode node) {
    if (node != null) {
        visit(node);
        preOrderTraversal(node.left);
        preOrderTraversal(node.right);
    }
}
```
前序遍历中，根节点永远第一个被访问。

后序遍历于访问子节点之后访问当前节点。因此命名为“后序遍历”。
```C++
void postOrderTraversal(TreeNode node) {
    if (node != null) {
        postOrderTraversal(node.left);
        postOrderTraversal(node.right);
        visit(node);
    }
}
```
后序遍历中，根节点永远最后一个被访问。

## 二叉树
二叉树是指每个节点至多只有两个子节点的树。

有一些特殊的二叉树
### 二叉搜索树
二叉搜索树应满足如下条件：对于任意节点，其左子孙节点小于或等于当前节点，而后者又小于所有右子孙节点。

### 平衡树
平衡一棵树并不表示左子树和右子树的大小完全相同。“平衡”树实际上多半意味着“不是非常不平衡”的树。它的平衡性足以确保执行insert和find操作可以在`O(logN)`的时间复杂度内完成，但其并不一定是严格意义上的平衡树。平衡树的两种常见类型是红黑树和AVL树。

### 完整二叉树
完整二叉树是二叉树的一种，其中除了最后一层外，树的每层都被完全填充。而树的最后一层，其节点是从左到右填充的。

### 满二叉树
满二叉树是二叉树的一种，其中每个节点都有零个或两个子节点，也就是不存在只有一个子节点的节点。

### 完美二叉树
完美二叉树既是完整二叉树，又是满二叉树。所有叶节点都处于同一层，而此层包含最大的节点数，正好有`2^(k
-1)`个节点才能满足这个条件（其中k是树的层数）。

### 二叉堆（小顶堆与大顶堆）
一个小顶堆是一棵完整二叉树（也就是说，除了底层最右边的元素，树的每层都被填满了），其中每个节点都小于其子节点。因此，根是树中的最小元素。

### 单词查找树（前序树）
> 单词查找树是N叉树的一种变体，其中每个节点都存储字符, 整棵树的每条路径自上而下表示一个单词。便于快速前缀查找。`*`节点（有时被称为“空节点”）时常被用于指代完整的单词。例如，如果`*`节点出现在MANY单词之下，那么MANY则为一个完整的单词。MA路径的出现表示有部分单词是以MA开头的。`*`节点在实际实现当中通常被表示为一种特殊的子节点（比如`TerminatingTrieNode`节点，它继承于`TrieNode`节点）。或者我们也可以在父节点中使用一个布尔变量`terminates`来表示单词结束。单词查找树的节点可以有1至`ALPHABET_SIZE + 1`个子节点（如果使用布尔变量而不是*节点，则可能有0至`ALPHABET_SIZE`个子节点）。
> 
> 单词查找树可以在`O(K)`的时间复杂度内检查一个字符串是否是有效前缀，其中K是该字符串的长度。这实际上是与散列表有着相同的运行时间复杂度。散列表必须读取输入中的所有字符，在单词查找的情况下，其需要`O(K)`的时间。

## 图
图可以分为有向图或无向图。有向图的边可以类比为单行道，而无向图的边可以类比为双向车道。图可以包括多个相互隔离的子图。如果任意一对节点都存在一条路径，那么该图被称为连通图。

## 图的表示
### 邻接链表法
这是表示图的最常见的方法。每个顶点（或节点）存储一列相邻的顶点。在无向图中，边`(a，b)`会被存储两遍：在a的邻接顶点中存储一遍，在b的邻接顶点中存储一遍。图的节点类的实现方法和树的节点类基本一致。
```C++
class Graph {
    public Node[] nodes;
}

class Node {
    public String name;
    public Node[] children;
}
```
### 邻接矩阵法
邻接矩阵是N×N的布尔型矩阵（N是节点的数量），其中matrix[i][j]
的值为true，表示从节点i到节点j存在一条边。
```C++
```

## 图的搜索
两种常见的图搜索算法分别是深度优先搜索（depth-first search，DFS）和广度优先搜索（breadth-first search，BFS），如果我们想找到两个节点中的最短路径（或任意路径），BFS一般说来更加适宜。

### 深度优先搜索
实现DFS的伪代码。
```C++
void search(Node root) {
    if (root == null) return;
    visit(root);
    root.visited = true;
    for each (Node n in root.adjacent) {
        if (n.visited == false) {
            search(n);
        }
    }
}
```

### 宽度优先搜索
用到队列的迭代法往往最为有效。
```C++
void search(Node root) {
    Queue queue = new Queue();
    root.marked = true;
    queue.enqueue(root); // 加入队尾
    while (!queue.isEmpty()) {
        Node r = queue.dequeue(); // 从队列头部删除
        visit(r);
        foreach (Node n in r.adjacent) {
            if (n.marked == false) {
                n.marked = true;
                queue.enqueue(n)
            }
        }
    }
}
```

## 双向搜索
双向搜索用于查找起始节点和目的节点间的最短路径。它本质上是从起始节点和目的节点同时开始的两个广度优先搜索。当两个搜索相遇时，我们即找到了一条路径。
> 在传统的广度优先搜索中，在搜索的第一层我们需要搜索至多k个节点。在第二层，对于第一层k个节点中的每个节点，我们需要搜索至多k个节点。所以，至此为止我们需要总计搜索`k^2`个节点。我们需要进行d次该操作，所以会搜索`O(k^d)`个节点。在双向搜索中，我们会有两个相遇于约`d/2`层处（最短路径的中点）的搜索。从s点和t点开始的搜索分别访问了大约`k^(d/2)`个节点。总计大约`2k^(d/2)`或`O(k^(d/2))`个节点。
