Snappy是Google开源出的高效数据压缩与解压缩算法库，其目标并非是最高的数据压缩率，而是在**合理的压缩率基础上追求尽可能快的压缩和解压缩速度，其压缩和解压缩速度极快**，可以在单核处理器上达到250MB/s的压缩效率和500MB/s的解压缩效率。与此同时，Snappy相比其他压缩方案占用CPU时间更少。

数据压缩与解压缩本质上是通过增加CPU计算时间成本来换取较小的存储成本，以及网络和I/O传输成本。如果只是追求存储成本最小化，Snappy这种技术方案是不适用的，但是对于很多情形，在合理压缩率情况下追求最高的压缩和解压缩速度比单纯追求最小的存储成本更重要。

一般会说Snappy是基于LZ77压缩方案的，如果对Snappy源码进行分析，会发现如果要更准确地表述，应该说Snappy是基于LZSS算法的，因为其整体方案基本遵循LZSS的算法逻辑。LZSS是LZ77的优化方案，其效率更高。

# LZSS算法

与霍夫曼编码这种统计编码不同，LZ77是一种动态词典编码（Dictionary Coding）。词典编码的基本思路是：文本中的词用它在词典中表示位置的号码代替的无损数据压缩方法，一般分为静态词典方法和动态词典方法两种。采用静态词典编码技术时，编码器需要事先构造词典，解码器要事先知道词典。采用动态辞典编码技术时，编码器将从被压缩的文本中自动导出词典，解码器解码时边解码边构造解码词典。

1977年，Jacob Ziv和Abraham Lempel提出了LZ77算法，其论文描述了一种基于滑动窗口缓存的技术，该缓存用于保存最近刚刚处理的文本，而动态词典由滑动窗口内的文本构造出来的。

```C++
						----------
输入数据流	a  b  c  d  x | a  b  c | m ...
    					 ---------- |
    				|		|
            ----------        v     /
输出数据流	| a  b  c | d  x  p  m
            -----------       |
                 Y-------------           
```



LZ77的压缩算法使用了滑动窗口和前向缓冲区的概念。滑动窗口包含了前面处理过的若干源字符，前向缓冲区（Lookahead Buffer）包含了输入数据流中将要处理的所有后续字符。算法尝试将前向缓冲区的开始字符串与滑动窗口中的字符串进行最长匹配。如果没有发现匹配，前向缓冲区的第1个字符输出并且移入滑动窗口，滑动窗口中存在最久的字符被移出。如果找到匹配字符串，那么匹配字符串作为三元组输出＜指针，长度，后续字符>。其中的指针指出了匹配字符串在滑动窗口中的起始位置（也可以将指针设置为两个匹配字符串的起始位置差值，代表两者的相对位置），长度标明匹配字符串的长度，后续字符则指出前向缓冲区中除去匹配字符串后的第1个字符。

```C++
			Time=1
|------------------------------------|				
|	A  A  B  B  C  B | B  A  A  B  C |
|--------------------|---------------|
     滑动窗口区			前向缓冲区

             Time=2
|------------------------------------|
|	A  A  B  B  C  B  B | A  A  B  C |
|-----------------------|------------|
     滑动窗口区			前向缓冲区
```



LZSS对LZ77做出了改进，一个主要的改进点是：增加了最小匹配长度限制，当匹配字符串小于指定的最小匹配限制时，并不进行压缩输出，而是仍然滑动窗口右移一个字符。



# Snappy

Snappy在整体框架上基本遵循LZSS的压缩编码与解码方案。首先，Snappy设定最小匹配长度为4，即只有匹配长度大于等于4的字符串才进行压缩，相应地，其设定哈希表内的字符串片段固定长度也为4。其输出字符串的压缩形式为＜编码方案，匹配字符串起始位置差值，匹配字符串长度>。

除了上述的LZSS方案对应参数配置外，Snappy做了一些相对独特的优化。比如其在压缩数据时，将整个数据切割成32KB大小的数据块分别进行压缩，数据块之间独立无关联，这样两个字节即可表示匹配字符串的相对位置。再比如与LZSS不同的是，其滑动窗口每次后移的长度为4而不是1等。

# 参考资料

1. 大数据日知录