值类别是C++11标准中新引入的概念，具体来说它是<b><font color=FA8072>表达式的一种属性</font></b>，该属性将表达式分为3个类别，它们分别是左值(lvalue)、纯右值(prvalue)和将亡值(xvalue)。
```
                                        |->    lvalue(左值)
                        glvalue(泛左值)--
                                        |
                                        |->    xvalue(将亡值)
Expression(表达式)                      |
                        rvalue(右值) -- |
                                        |->   prvalue(纯右值)

```

表达式首先被分为了泛左值(glvalue)和右值(rvalue)，其中泛左值被进一步划分为左值和将亡值，右值又被划分为将亡值和纯右值。
1. 所谓泛左值是指一个通过评估能够确定对象、位域或函数的标识的表达式。简单来说，它确定了对象或者函数的标识(具名对象)。
2. 纯右值是指一个通过评估能够用于初始化对象和位域，或者能够计算运算符操作数的值的表达式。
3. 将亡值属于泛左值的一种，它表示资源可以被重用的对象和位域，通常这是因为它们接近其生命周期的末尾，另外也可能是经过右值引用的转换产生的。

---
左值是指非将亡值的泛左值，而右值则包含了纯右值和将亡值。这里的左值(lvalue)就是C++98的左值，而纯右值(prvalue)则对应C++98的右值，那么只需要弄清楚将亡值(xvalue)是如何产生的？从本质上说产生将亡值的途径有两种：
1. 使用类型转换将泛左值转换为该类型的右值引用。
```C++
static_cast<BigMemoryPool&&>(my_pool)
```

2. C++17标准中引入，我们称它为临时量实质化，指的是纯右值转换到临时对象的过程。每当纯右值出现在一个需要泛左值的地方时，临时量实质化都会发生，也就是说, 创建一个临时对象并且使用纯右值对其进行初始化，这个临时对象就是一个将亡值。
```C++
struct X {
  int a;
};

int main() {
  // X()是一个纯右值, 访问其成员变量a却需要一个泛左值
  // 发生临时量实质化, 将S()转换为将亡值, 再访问其成员变量a
  int b = X().a;
  return 0;
}
```


无论一个函数的实参是左值还是右值，其形参都是一个左值，即使这个形参看上去是一个右值引用。在C++11的标准库中提供了`std::move`函数模板，将左值转换为右值，这个函数内部也是用static_cast做类型转换，由于使用模板实现的函数，因此会根据传参类型自动推导返回类型，省去了指定转换类型。
```C++
void move_pool1(BigMemoryPool &&pool) {
    std::cout << "call move_pool" << std::endl;
    // 形参是左值, 采用复制构造函数对my_pool构造
    BigMemoryPool my_pool(pool);
}

void move_pool2(BigMemoryPool &&pool) {
    std::cout << "call move_pool" << std::endl;
    // 采用std::move将左值转换为右值
    // 使得采用移动构造函数对my_pool构造
    BigMemoryPool my_pool(std::move(pool));
}
```
[测试源文件](code/00_01_value_category.cpp)

## 万能引用和引用折叠
所谓的万能引用是因为发生了类型推导，在`T &&`和`auto &&`的初始化过程中都会发生类型的推导，如果已经有一个确定的类型，比如`int &&`，则是右值引用。

| 模板类型 | T实际类型 | 最终类型 |
| :------: | :-------: | :------: |
|   `T&`   |    `R`    |   `R&`   |
|   `T&`   |   `R&`    |   `R&`   |
|   `T&`   |  `R &&`   |   `R&`   |
|  `T&&`   |    `R`    |  `R&&`   |
|  `T&&`   |   `R&`    |   `R&`   |
|  `T&&`   |   `R&&`   |  `R&&`   |

只要有左值引用参与进来，最后推导的结果就是一个左值引用。只有实际类型是一个非引用类型或者右值引用类型时，最后推导出来的才是一个右值引用。