C++11标准中添加了`thread_local`说明符来声明线程局部存储变量。线程局部存储是指对象内存在线程开始后分配，线程结束时回收且每个线程有该对象自己的实例，简单地说，线程局部存储的对象都是独立于各个线程的。

>`thread_loca`l声明的变量在行为上非常像静态变量，只不过多了线程属性，当然这也是线程局部存储能出现在我们的视野中的一个关键原因。
>
>`thread_local`能够解决全局变量或者静态变量在多线程操作中存在的问题，一个典型的例子就是`errno`。`errno`通常用于存储程序当中上一次发生的错误，早期它是一个静态变量，由于当时大多数程序是单线程的，因此没有任何问题。但是到了多线程时代，这种`errno`就不能满足需求了。设想一下，一个多线程程序的线程A在某个时刻刚刚调用过一个函数，正准备获取其错误码，也正是这个时刻，另外一个线程B在执行了某个函数后修改了这个错误码，那么线程A接下来获取的错误码自然不会是它真正想要的那个。这种线程间的竞争关系破坏了`errno`的准确性，导致不可确定的结果。为了规避由此产生的不确定性，`POSIX`将`errno`重新定义为线程独立的变量，为了实现这个定义就需要用到线程局部存储，直到C++11之前，`errno`都是一个静态变量，而从C++11开始`errno`被修改为一个线程局部存储变量。

`thread_local`说明符可以用来声明线程生命周期的对象，它能与`static`或`extern`结合，分别指定内部或外部链接，不过`static`并不影响对象的生命周期，也就是说`static`并不影响其线程局部存储的属性。

```C++
struct X {
  thread_local static int i;
};

thread_local X a;

int main(){
  thread_local X b;
}
```

线程局部存储只是定义了对象的生命周期，而没有定义可访问性。也就是说，我们可以获取线程局部存储变量的地址并将其传递给其他线程，并且其他线程可以在其生命周期内自由使用变量。不过这样做危险性极大，一旦没有掌握好目标线程的声明周期，就很可能导致内存访问异常，造成未定义的程序行为，通常情况下是程序崩溃。

值得注意的是，使用取地址运算符&取到的线程局部存储变量的地址是运行时被计算出来的，在线程创建时才确定其内存地址，它不是一个常量，也就是说无法和`constexpr`结合：

```C++
thread_local int tv;
static int sv;

int main() {
  constexpr int *sp = &sv;    // 编译成功，sv的地址在编译时确定
  constexpr int *tp = &tv;    // 编译失败，tv的地址在运行时确定
}
```



深入操作系统层面，探究系统处理线程局部存储的方法