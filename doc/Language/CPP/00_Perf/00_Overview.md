1. <b><font color=FA8072>优化循环，提升效率。
在多重循环中，CPU跨切循环层的次数会对循环的效率产生相对较大的影响，所以如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少CPU跨切循环层的次数，提高效率。</font></b> 据统计，在C++/C的循环语句中，for语句是使用频率最高的，while语句次之，do语句最少用。

​	  什么是CPU跨切循环？
> 由外层循环进入内层循环需要重新初始化循环计数器的，包括保存外层循环的计数器和加载内层循环计数器，退出内层的时候再恢复外层循环计数器。把长循环放在里面可以显著减少这些操作的数量。所以，在多重嵌套循环中，如有可能，应当将最长的循环放在内层，最短循环放在外层，这样就可以减少cpu跨切循环层的次数，从而优化程序性能。
>
> 来自：https://zhidao.baidu.com/question/1690002647584698148.html

2. <b><font color=FA8072>改造switch语句。对于case的值，推荐按照它们发生的相对频率来排序，把最可能发生的情况放在第一位，最不可能的情况放在最后。</font></b>switch语句在具体的执行过程中可以转化成多种不同算法的代码，其中最常见的是跳转表和比较链/树，它们所生成的代码将按照顺序进行比较，如果发现匹配，程序就跳转到满足条件的语句上并执行。

---

3. 精简函数参数，减少参数个数可以提高函数调用的效率
函数在调用时会建立堆栈来存储所需的参数值，因此函数的调用负担会随着参数列表的增长而增加。如果精简后的参数还是比较多，那么可以把参数列表封装进一个单独的类中，并且可以通过引用进行传递。这种方式将会节省一定的时间，对于那些执行时间较短但是调用频率较高的函数来说尤为有效。

4. 谨慎使用内嵌汇编。汇编语言与其他高级语言相比，更接近机器语言，效率更高，所以在应用程序中如果碰那些对时间要求苛刻的部分，可以采用汇编语言来重写。

5. 努力减少内存碎片。
  通常而言，应用程序是不受内存泄露影响的，但是如果应用程序运行了很长一段时间，频繁地分配和释放内存则会导致其性能逐渐下降，甚至有可能致使程序崩溃。这是因为经常性地动态分配和释放内存会造成堆碎片，尤其是应用程序分配的是很小的内存块时。支离破碎的堆空间可能有许多空闲块，但这些块既小又不连续，像一盘散沙，很难被再次使用。就像下面的堆空间（0表示空闲内存块，1表示使用中的内存块）：

  ```
  100101010000101010110
  ```

  上述堆是高度分散的。如果想要分配一个包含5个单位（即5个0）的内存块，将是不可能的，尽管系统总共还有12个空闲的空间单位，但可用内存是不连续的。而下面的堆可用内存空间虽然少，却不是支离破碎的：

  ```
  1111111111000000
  ```

  可以能做些什么来避免上面所说的堆碎片呢？

  - 尽可能少地使用动态内存。在大多数情况下，可以使用静态或自动储存，或者使用STL容器，减少对动态内存的依赖。

  - 尽量分配和重新分配大块的内存块，降低内存碎片发生的几率。例如，不要为一个单一的对象分配内存，而是一次分配一个对象数组。当然，我们也可以求助于自定义的内存池。


6. 正确地使用内联函数

   在函数名称前加inline，这仅仅是对编译器提出的建议，至于是采取还是忽略这个建议完全由编译器自行决定。inline关键字告诉编译器最好能采用内联方式来处理。但是，编译器可能会生成单独的函数实例和标准的调用链接，而不是将这个函数内联地插入到代码中。只有当函数非常短小的时候使用inline才能得到预想中的效果。对于编译器来说，函数内联与否取决于以下关键性的因素：

   - 函数体的大小

   - 是否有局部对象被声明

   - 函数的复杂性(是否存在函数调用、递归等)

     如果编译器忽略了程序员的inline建议，拒绝这个内联函数，那么这个函数会被当成普通的函数来处理。如果决定使用内联函数，那么还得面对两个令人头疼的问题：


​	该如何进行维护？

1. 一个函数开始的时候可能满足了设定的内联标准，并以内联的形式出现，但是随着系统的扩展升级，函数体中增添了一些新的功能，函数变得复杂庞大了，这就使内联函数不再适合内联，此时需要把函数前面的inline去除掉，并把函数体放到相应的源文件中，这会使维护的难度有所增加。
2. 不可避免的重新编译。当内联函数实现改变的时候，用户必须重新编译他们的代码以反映出这种改变。而对于非内联函数，用户仅仅需要重新连接。

所以，使用内联关键字inline是一个经验活儿，需要依靠积累的经验来进行判断。合理地使用内联，可以提高程序的性能，反之，会带来意想不到的副作用！

7. 用初始化代替赋值
8. 尽可能地减少临时对象

| 产生情形   | 避免方法                                                     |
| ---------- | ------------------------------------------------------------ |
| 参数       | 采用常量引用或指针取代传值                                   |
| 前缀和后缀 | 优先采用前缀操作                                             |
| 参数转换   | 尽量避免                                                     |
| 返回值     | 遵循single-entry/single-exit原则，避免同一个函数中存在多个return语句 |


9. 最后再优化代码。

   不成熟的优化是万恶之源，这是前辈留给我们的谆谆教诲，也是我们在做代码优化时必须恪守的准则。在进行代码优化之前，我们需要先回答以下几个问题：

   1. 算法是否正确？
      这是在做代码优化前必须要搞清楚的一个问题。对一个错误的程序做优化，这是一件多么荒谬的事儿啊！
   2. 如何在代码优化和可读性之间进行选择？
      在默认情况下，我们首要关注的是代码的清晰情况与易读性。清晰的代码更容易理解，更容易重构，也更容易优化。而代码的优化只在必要的时候进行。同时，也要避免过度优化，杜绝代码“大杂烩”。
   3. 该如何优化？
      按照经典的“20-80原则”，代码执行时间的80%花费在20%的代码上，所以我们在优化之前首先要找到代码效率的瓶颈所在，确定那20%的代码在哪里。这个工作可以借助编译器附带的代码分析（profiling）工具来完成（如果所使用的编译器具有这样的工具）。如果对这些瓶颈部分作一些特定的优化，其效果将最为明显有效。
   4. 如何选择优化方向？
      代码优化也要分层次进行，先算法，再数据结构，最后才是实现细节，这样才会最有效。如果对现存的所有代码实现细节的优化都不能让程序跑得更快，这时就该考虑一下是不是优化的方向出了什么问题。

# 参考资料
1. 《编写高质量代码：改善C++程序的150个建议》