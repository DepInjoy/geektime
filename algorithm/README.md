该目录主要是对算法和数据结构学习的记录和总结

# 缓存策略

# 排序算法
此部分是结合浙江大学的MOOC陈越、何钦铭的《数据结构》为主线进行排序算法实践和记录。
## 内部排序
```
void X_Sort ( ElementType A[], int N )
	大多数情况下，为简单起见，讨论从小大的整数排序
	N是正整数
	只讨论基于比较的排序(> = < 有定义)
	只讨论内部排序，内部排序是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列。

稳定性：任意两个相等的数据，排序前后的相对位置不发生改变
```
### 简单排序

#### 冒泡排序
稳定性:稳定
时间复杂度：
- 最坏情况:`O(N^2)`，当输入的数据是逆序，每一趟冒泡都需要数据交换并将其中一个数据放在应该存放的位置，数据复杂度为`O(N(N-1))`即`O(N^2)`
- 最好情况:`O(N)`,当输入正好是按照顺序已排好的数据时，只需要遍历一遍，无数据交换，即可。

#### 插入排序
稳定性:稳定
时间复杂度:
- 最坏情况:`O(N^2)`，当输入的数据是逆序
- 最好情况:`O(N)`，输入的数据正好是已经排好的数据，遍历一遍就好

> 时间复杂度下界
>
> - 对于下标i<j，如果A[i]>A[j]，则称(i,j)是一对逆序对(inversion)
>     - 交换2个相邻元素正好消去1个逆序对！
>     - 插入排序：T(N, I) = O( N+I ) — 如果序列基本有序，则插入排序简单且高效
>
> 定理：任意N个不同元素组成的序列平均具有N(N-1)/4个逆序对。
> 定理：任何仅以交换相邻两元素来排序的算法，其平均时间复杂度为O(N^2)。

因此，要提高算法效率，我们必须
- 每次消去不止1个逆序对！
- 每次交换相隔较远的2个元素！